<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Personal Music Tool</title>

<style>
:root {
  /* Light Mode */
  --bg-primary: #ffffff;
  --bg-secondary: #f8f9fa;
  --bg-card: #ffffff;
  --bg-input: #f1f3f5;
  --text-primary: #212529;
  --text-secondary: #6c757d;
  --border-color: #dee2e6;
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.15);
  
  /* Platform Colors */
  --spotify-green: #1db954;
  --spotify-green-hover: #1ed760;
  --apple-red: #fa243c;
  --apple-red-hover: #ff3b5c;
  --youtube-red: #ff0000;
  --youtube-red-hover: #ff1a1a;
  
  /* Transitions */
  --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

[data-theme="dark"] {
  /* Dark Mode */
  --bg-primary: #0f0f0f;
  --bg-secondary: #1a1a1a;
  --bg-card: #1e1e1e;
  --bg-input: #2a2a2a;
  --text-primary: #ffffff;
  --text-secondary: #b3b3b3;
  --border-color: #333333;
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4);
  --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.5);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  transition: var(--transition);
  min-height: 100vh;
  line-height: 1.6;
}

/* Top Bar */
.top-bar {
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border-color);
  padding: 1rem 2rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  z-index: 100;
  backdrop-filter: blur(10px);
  box-shadow: var(--shadow-sm);
}

.top-bar-left {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.platform-tab {
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 8px;
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
  transition: var(--transition);
  color: white;
  position: relative;
  overflow: hidden;
}

.platform-tab::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.2);
  transition: left 0.3s;
}

.platform-tab:hover::before {
  left: 100%;
}

.platform-tab.active {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.platform-tab.spotify {
  background: var(--spotify-green);
}

.platform-tab.spotify:hover {
  background: var(--spotify-green-hover);
}

.platform-tab.apple {
  background: var(--apple-red);
}

.platform-tab.apple:hover {
  background: var(--apple-red-hover);
}

.platform-tab.youtube {
  background: var(--youtube-red);
}

.platform-tab.youtube:hover {
  background: var(--youtube-red-hover);
}

.theme-toggle {
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  padding: 0.5rem 1rem;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1.2rem;
  transition: var(--transition);
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.theme-toggle:hover {
  background: var(--bg-input);
  transform: scale(1.05);
}

/* Main Layout */
.main-container {
  display: grid;
  grid-template-columns: 1fr 380px;
  gap: 2rem;
  padding: 2rem;
  max-width: 1600px;
  margin: 0 auto;
}

/* Left Column - Search Area */
.search-area {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.search-panel {
  display: none;
  animation: fadeIn 0.3s ease-in;
}

.search-panel.active {
  display: block;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.search-card {
  background: var(--bg-card);
  border-radius: 16px;
  padding: 1.5rem;
  box-shadow: var(--shadow-md);
  border: 1px solid var(--border-color);
}

.search-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1.5rem;
}

.search-header h2 {
  font-size: 1.5rem;
  font-weight: 700;
}

.spotify-login-btn {
  background: var(--spotify-green);
  color: white;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: var(--transition);
  font-size: 0.9rem;
}

.spotify-login-btn:hover {
  background: var(--spotify-green-hover);
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.search-input-group {
  display: flex;
  gap: 0.75rem;
  margin-bottom: 1.5rem;
}

.search-input {
  flex: 1;
  padding: 0.875rem 1rem;
  border: 2px solid var(--border-color);
  border-radius: 12px;
  background: var(--bg-input);
  color: var(--text-primary);
  font-size: 1rem;
  transition: var(--transition);
}

.search-input:focus {
  outline: none;
  border-color: var(--spotify-green);
  box-shadow: 0 0 0 3px rgba(29, 185, 84, 0.1);
}

.search-btn {
  padding: 0.875rem 1.5rem;
  border: none;
  border-radius: 12px;
  background: var(--spotify-green);
  color: white;
  font-weight: 600;
  cursor: pointer;
  transition: var(--transition);
  font-size: 1rem;
}

.search-btn:hover {
  background: var(--spotify-green-hover);
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.search-btn.apple {
  background: var(--apple-red);
}

.search-btn.apple:hover {
  background: var(--apple-red-hover);
}

.search-btn.youtube {
  background: var(--youtube-red);
}

.search-btn.youtube:hover {
  background: var(--youtube-red-hover);
}

.results-container {
  margin-top: 1rem;
}

.result-item {
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 1rem;
  margin-bottom: 0.75rem;
  cursor: pointer;
  transition: var(--transition);
}

.result-item:hover {
  background: var(--bg-input);
  transform: translateX(4px);
  box-shadow: var(--shadow-sm);
  border-color: var(--spotify-green);
}

.result-title {
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 0.25rem;
  font-size: 1rem;
}

.result-artist {
  color: var(--text-secondary);
  font-size: 0.9rem;
}

/* Right Column - Player Card */
.player-card {
  position: sticky;
  top: 100px;
  background: var(--bg-card);
  border-radius: 16px;
  padding: 1.5rem;
  box-shadow: var(--shadow-lg);
  border: 1px solid var(--border-color);
  height: fit-content;
  max-height: calc(100vh - 120px);
  overflow-y: auto;
}

.player-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.player-title {
  font-size: 1.1rem;
  font-weight: 700;
  color: var(--text-primary);
}

.platform-badge {
  padding: 0.35rem 0.75rem;
  border-radius: 20px;
  font-size: 0.75rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.platform-badge.spotify {
  background: var(--spotify-green);
  color: white;
}

.platform-badge.apple {
  background: var(--apple-red);
  color: white;
}

.platform-badge.youtube {
  background: var(--youtube-red);
  color: white;
}

.player-content {
  min-height: 200px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--bg-secondary);
  border-radius: 12px;
  padding: 1rem;
}

.player-placeholder {
  text-align: center;
  color: var(--text-secondary);
  font-size: 0.9rem;
}

.player-embed {
  width: 100%;
  border-radius: 12px;
  overflow: hidden;
}

.player-embed iframe {
  width: 100%;
  border: none;
  border-radius: 12px;
}

/* Lyrics Section */
.lyrics-section {
  margin-top: 1.5rem;
  padding-top: 1.5rem;
  border-top: 1px solid var(--border-color);
}

.lyrics-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.lyrics-title {
  font-size: 1rem;
  font-weight: 700;
  color: var(--text-primary);
}

.lyrics-source {
  font-size: 0.75rem;
  color: var(--text-secondary);
  padding: 0.25rem 0.5rem;
  background: var(--bg-secondary);
  border-radius: 12px;
}

.lyrics-content {
  max-height: 400px;
  overflow-y: auto;
  padding: 1rem;
  background: var(--bg-secondary);
  border-radius: 12px;
  font-size: 0.95rem;
  line-height: 1.8;
  color: var(--text-primary);
  white-space: pre-wrap;
  text-align: left;
}

.lyrics-editor-toolbar {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 0.5rem;
}

.lyrics-editor-textarea {
  width: 100%;
  min-height: 220px;
  max-height: 520px;
  resize: vertical;
  padding: 0.75rem;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  background: var(--bg-card);
  color: var(--text-primary);
  font-size: 0.95rem;
  line-height: 1.6;
  font-family: inherit;
}

.check-report {
  margin-top: 0.75rem;
  padding: 0.75rem;
  border-radius: 8px;
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  font-size: 0.9rem;
}

.lyrics-loading {
  text-align: center;
  color: var(--text-secondary);
  padding: 2rem;
  font-size: 0.9rem;
}

.lyrics-error {
  text-align: center;
  color: var(--text-secondary);
  padding: 1rem;
  font-size: 0.9rem;
}

.lyrics-tabs {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.lyrics-tab {
  padding: 0.5rem 1rem;
  border: 1px solid var(--border-color);
  background: var(--bg-secondary);
  color: var(--text-primary);
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.85rem;
  transition: var(--transition);
}

.lyrics-tab.active {
  background: var(--spotify-green);
  color: white;
  border-color: var(--spotify-green);
}

.lyrics-tab:hover {
  background: var(--bg-input);
}

/* Song Info Section */
.song-info-section {
  margin-top: 1.5rem;
  padding-top: 1.5rem;
  border-top: 1px solid var(--border-color);
}

.song-info-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.song-info-title {
  font-size: 1rem;
  font-weight: 700;
  color: var(--text-primary);
}

.song-info-tabs {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.song-info-tab {
  padding: 0.5rem 1rem;
  border: 1px solid var(--border-color);
  background: var(--bg-secondary);
  color: var(--text-primary);
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.85rem;
  transition: var(--transition);
}

.song-info-tab.active {
  background: var(--spotify-green);
  color: white;
  border-color: var(--spotify-green);
}

.song-info-tab:hover {
  background: var(--bg-input);
}

.song-info-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0.75rem;
}

.song-info-item {
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 1rem;
  text-align: center;
  transition: var(--transition);
}

.song-info-item:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-sm);
  border-color: var(--spotify-green);
}

.song-info-label {
  font-size: 0.75rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 0.5rem;
  font-weight: 600;
}

.song-info-value {
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--text-primary);
}

.song-info-value-large {
  font-size: 1.5rem;
}

.progress-bar {
  width: 100%;
  height: 6px;
  background: var(--bg-input);
  border-radius: 3px;
  overflow: hidden;
  margin-top: 0.5rem;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--spotify-green), var(--spotify-green-hover));
  border-radius: 3px;
  transition: width 0.3s ease;
}

.song-info-loading {
  text-align: center;
  color: var(--text-secondary);
  padding: 2rem;
  font-size: 0.9rem;
}

.song-info-error {
  text-align: center;
  color: var(--text-secondary);
  padding: 1rem;
  font-size: 0.9rem;
}

/* Responsive Design */
@media (max-width: 1024px) {
  .main-container {
    grid-template-columns: 1fr;
  }
  
  .player-card {
    position: relative;
    top: 0;
    max-height: none;
  }
}

@media (max-width: 768px) {
  html {
    font-size: 16px; /* Prevent zoom by using proper base font size */
    -webkit-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
  }
  
  body {
    font-size: 16px; /* Ensure readable text without zoom */
  }
  
  .top-bar {
    padding: 0.75rem 1rem;
    flex-wrap: wrap;
  }
  
  .top-bar-left {
    width: 100%;
    justify-content: space-between;
    gap: 0.5rem;
  }
  
  .platform-tab {
    flex: 1;
    min-width: 0;
    padding: 0.65rem 0.75rem;
    font-size: 0.8rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  .theme-toggle {
    padding: 0.4rem 0.75rem;
    font-size: 1rem;
  }
  
  .theme-toggle span:last-child {
    display: none; /* Hide text on mobile, show only icon */
  }
  
  .main-container {
    padding: 1rem 0.75rem;
    gap: 1.25rem;
  }
  
  .search-card {
    padding: 1.25rem 1rem;
  }
  
  .search-header h2 {
    font-size: 1.25rem;
  }
  
  .search-input {
    font-size: 16px; /* Prevent iOS zoom on input focus */
    padding: 0.75rem 0.875rem;
  }
  
  .search-btn {
    padding: 0.75rem 1.25rem;
    font-size: 0.95rem;
  }
  
  .player-card {
    padding: 1.25rem 1rem;
  }
  
  .player-title {
    font-size: 1rem;
  }
  
  .result-item {
    padding: 0.875rem;
  }
  
  .result-title {
    font-size: 0.95rem;
  }
  
  .result-artist {
    font-size: 0.85rem;
  }
  
  .lyrics-content {
    max-height: 300px;
    font-size: 0.9rem;
    padding: 0.875rem;
  }
  
  .lyrics-tabs {
    flex-wrap: wrap;
  }
  
  .lyrics-tab {
    flex: 1;
    min-width: 80px;
    padding: 0.4rem 0.75rem;
    font-size: 0.8rem;
  }
  
  .song-info-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 0.5rem;
  }
  
  .song-info-item {
    padding: 0.75rem;
  }
  
  .song-info-value {
    font-size: 1.1rem;
  }
  
  .song-info-value-large {
    font-size: 1.3rem;
  }
  
  .song-info-tabs {
    flex-wrap: wrap;
  }
  
  .song-info-tab {
    flex: 1;
    min-width: 80px;
    padding: 0.4rem 0.75rem;
    font-size: 0.8rem;
  }
}

@media (max-width: 480px) {
  .top-bar {
    padding: 0.625rem 0.75rem;
  }
  
  .platform-tab {
    padding: 0.55rem 0.5rem;
    font-size: 0.75rem;
  }
  
  .main-container {
    padding: 0.75rem 0.5rem;
    gap: 1rem;
  }
  
  .search-card {
    padding: 1rem 0.875rem;
  }
  
  .player-card {
    padding: 1rem 0.875rem;
  }
}

/* Scrollbar Styling */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--text-secondary);
}

/* Lyrics editor overlay for per-line highlights */
.editor-wrap {
  position: relative;
}
.lyrics-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  font-family: inherit;
  font-size: 0.95rem;
  line-height: 1.6;
  white-space: pre-wrap;
  padding: 0.75rem;
  overflow: hidden;
  color: transparent; /* keep text invisible but allow selection via JS if needed */
}
.lyrics-overlay .line {
  display: block;
}
.lyrics-overlay .highlight {
  background: rgba(255, 210, 77, 0.18);
  border-left: 3px solid rgba(255, 180, 0, 0.9);
  color: inherit;
  pointer-events: auto;
}
</style>
</head>

<body>
  <!-- Top Bar -->
  <div class="top-bar">
    <div class="top-bar-left">
      <button class="platform-tab spotify active" data-platform="spotify">
        üéµ Spotify
      </button>
      <button class="platform-tab apple" data-platform="apple">
        üçé Apple Music
      </button>
      <button class="platform-tab youtube" data-platform="youtube">
        ‚ñ∂Ô∏è YouTube
      </button>
    </div>
    <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
      <span id="themeIcon">üåô</span>
      <span id="themeText">Dark</span>
    </button>
    <button class="search-btn" onclick="showDemo()" style="margin-left:0.75rem">Show Demo</button>
  </div>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Left Column - Search Area -->
    <div class="search-area">
      <!-- Spotify Search Panel -->
      <div class="search-panel active" id="spotifyPanel">
        <div class="search-card">
          <div class="search-header">
            <h2>Spotify Search</h2>
            <button class="spotify-login-btn" onclick="login()">Login</button>
          </div>
          <div class="search-input-group">
            <input 
              type="text" 
              id="sQuery" 
              class="search-input" 
              placeholder="Search for songs, artists, albums..."
              onkeypress="if(event.key === 'Enter') spotifySearch()"
            >
            <button class="search-btn" onclick="spotifySearch()">Search</button>
          </div>
          <div class="results-container" id="sResults"></div>
        </div>
      </div>

      <!-- Apple Music Search Panel -->
      <div class="search-panel" id="applePanel">
        <div class="search-card">
          <div class="search-header">
            <h2>Apple Music Search</h2>
          </div>
          <div class="search-input-group">
            <input 
              type="text" 
              id="aQuery" 
              class="search-input" 
              placeholder="Search for songs, artists, albums..."
              onkeypress="if(event.key === 'Enter') appleSearch()"
            >
            <button class="search-btn apple" onclick="appleSearch()">Search</button>
          </div>
          <div class="results-container" id="aResults"></div>
        </div>
      </div>

      <!-- YouTube Search Panel -->
      <div class="search-panel" id="youtubePanel">
        <div class="search-card">
          <div class="search-header">
            <h2>YouTube Search</h2>
          </div>
          <div class="search-input-group">
            <input 
              type="text" 
              id="yQuery" 
              class="search-input" 
              placeholder="Search for songs, videos..."
              onkeypress="if(event.key === 'Enter') youtubeSearch()"
            >
            <button class="search-btn youtube" onclick="youtubeSearch()">Search</button>
          </div>
          <div class="results-container" id="yResults"></div>
        </div>
      </div>
</div>

    <!-- Right Column - Player Card -->
    <div class="player-card">
      <div class="player-header">
        <div class="player-title">Now Playing</div>
        <div class="platform-badge" id="playerBadge" style="display: none;">Spotify</div>
      </div>
      <div class="player-content" id="player">
        <div class="player-placeholder">
          Select a song to start playing
        </div>
      </div>
      
      <!-- Song Info Section -->
      <div class="song-info-section" id="songInfoSection" style="display: none;">
        <div class="song-info-header">
          <div class="song-info-title">Song Analysis</div>
        </div>
        <div class="song-info-tabs">
          <button class="song-info-tab active" data-source="tunebat" onclick="switchSongInfoSource('tunebat')">Tunebat</button>
          <button class="song-info-tab" data-source="statsfm" onclick="switchSongInfoSource('statsfm')">Stats.fm</button>
        </div>
        <div class="song-info-content" id="songInfoContent">
          <div class="song-info-loading">Loading song info...</div>
        </div>
      </div>
      
      <!-- Lyrics Section -->
      <div class="lyrics-section" id="lyricsSection" style="display: none;">
        <div class="lyrics-header">
          <div class="lyrics-title">Lyrics</div>
          <div class="lyrics-source" id="lyricsSource"></div>
        </div>
        <div class="lyrics-tabs">
          <button class="lyrics-tab" data-source="best" onclick="switchLyricsSource('best')">Best Lyrics</button>
          <button class="lyrics-tab" data-source="genius" onclick="switchLyricsSource('genius')">Genius</button>
          <button class="lyrics-tab" data-source="lrclib" onclick="switchLyricsSource('lrclib')">LRCLib</button>
        </div>
        <div class="lyrics-content" id="lyricsContent">
          <div class="lyrics-loading">Loading lyrics...</div>
        </div>
      </div>
    </div>
</div>

  <script>
    // Current active platform
    let currentPlatform = 'spotify';
    let currentPlayerPlatform = null;
    let currentSongInfo = null;
    let currentLyricsSource = 'best'; // Default to best lyrics
    let currentSongInfoSource = 'tunebat';
    let currentSpotifyId = null;

    // Theme Management
    const themeToggle = document.getElementById('themeToggle');
    const themeIcon = document.getElementById('themeIcon');
    const themeText = document.getElementById('themeText');
    const html = document.documentElement;

    // Load saved theme
    const savedTheme = localStorage.getItem('theme') || 'dark';
    html.setAttribute('data-theme', savedTheme);
    updateThemeIcon(savedTheme);

    function updateThemeIcon(theme) {
      if (theme === 'dark') {
        themeIcon.textContent = 'üåô';
        themeText.textContent = 'Dark';
      } else {
        themeIcon.textContent = '‚òÄÔ∏è';
        themeText.textContent = 'Light';
      }
    }

    themeToggle.addEventListener('click', () => {
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      html.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      updateThemeIcon(newTheme);
    });

    // Platform Tab Switching
    const platformTabs = document.querySelectorAll('.platform-tab');
    const searchPanels = document.querySelectorAll('.search-panel');

    platformTabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const platform = tab.dataset.platform;
        switchPlatform(platform);
      });
    });

    function switchPlatform(platform) {
      currentPlatform = platform;

      // Update active tab
      platformTabs.forEach(t => t.classList.remove('active'));
      document.querySelector(`[data-platform="${platform}"]`).classList.add('active');

      // Update active panel
      searchPanels.forEach(p => p.classList.remove('active'));
      document.getElementById(`${platform}Panel`).classList.add('active');

      // Update search button color
      const searchBtns = document.querySelectorAll('.search-btn');
      searchBtns.forEach(btn => {
        btn.classList.remove('spotify', 'apple', 'youtube');
        btn.classList.add(platform);
      });
    }

    // Update Player Badge
    function updatePlayerBadge(platform) {
      const badge = document.getElementById('playerBadge');
      if (platform) {
        badge.textContent = platform.charAt(0).toUpperCase() + platform.slice(1);
        badge.className = `platform-badge ${platform}`;
        badge.style.display = 'block';
        currentPlayerPlatform = platform;
      } else {
        badge.style.display = 'none';
        currentPlayerPlatform = null;
      }
    }

    // Update Player
    function updatePlayer(embedHtml, platform, songInfo = null, spotifyId = null, previewUrl = null, extra = {}) {
      const player = document.getElementById('player');
      // Build embed area and controls area
      player.innerHTML = `
        <div class="player-embed">${embedHtml}</div>
        <div id="playerControls" style="margin-top:0.75rem"></div>
      `;
      updatePlayerBadge(platform);

      // If previewUrl is provided, create HTML5 audio with capture button
      if (previewUrl) {
        setupAudioPreview(previewUrl, platform);
      }

      // If extra.youtubeId is provided, initialize YouTube JS API player for timestamp capture
      if (extra && extra.youtubeId) {
        setupYouTubePlayer(extra.youtubeId);
      }

      // Store song info for lyrics and song analysis
      if (songInfo) {
        currentSongInfo = songInfo;
        currentSpotifyId = spotifyId;

        // Auto-switch to Stats.fm if Spotify track ID is available
        if (spotifyId && platform === 'spotify') {
          currentSongInfoSource = 'statsfm';
          // Update active tab
          document.querySelectorAll('.song-info-tab').forEach(tab => {
            tab.classList.toggle('active', tab.dataset.source === 'statsfm');
          });
        }

        loadLyrics(songInfo.title, songInfo.artist, currentLyricsSource);
        loadSongInfo(songInfo.title, songInfo.artist, currentSongInfoSource, spotifyId);
      } else {
        currentSongInfo = null;
        currentSpotifyId = null;
        document.getElementById('lyricsSection').style.display = 'none';
        document.getElementById('songInfoSection').style.display = 'none';
      }

      // Auto-switch to the platform tab
      if (platform !== currentPlatform) {
        switchPlatform(platform);
      }
    }

    // Setup audio preview controls and a capture button to insert timestamp
    function setupAudioPreview(previewUrl, platform) {
      const controls = document.getElementById('playerControls');
      if (!controls) return;
      controls.innerHTML = `
        <audio id="previewAudio" controls src="${previewUrl}" style="width:100%"></audio>
        <div style="display:flex;gap:0.5rem;margin-top:0.5rem">
          <button class="search-btn" onclick="captureAudioTime()">Capture Time</button>
          <button class="search-btn" onclick="insertCurrentTimeIntoEditor()">Insert Current</button>
          <button class="search-btn" onclick="saveNotesForEditor()">Save Notes</button>
        </div>
      `;
    }

    function captureAudioTime() {
      const audio = document.getElementById('previewAudio');
      if (!audio) return alert('No preview audio available');
      const t = audio.currentTime || 0;
      const stamp = formatTimestamp(t);
      promptInsertOrCopy(stamp);
    }

    function insertCurrentTimeIntoEditor() {
      const audio = document.getElementById('previewAudio');
      if (!audio) return alert('No preview audio available');
      const t = audio.currentTime || 0;
      const stamp = formatTimestamp(t);
      insertAtCursor(document.getElementById('lyricsEditor'), stamp + '\n');
    }

    function promptInsertOrCopy(stamp) {
      if (confirm(`Insert timestamp ${stamp} into lyrics editor? (Cancel to copy)`)) {
        const ta = document.getElementById('lyricsEditor');
        if (ta) insertAtCursor(ta, stamp + '\n');
      } else {
        navigator.clipboard && navigator.clipboard.writeText(stamp).then(()=>alert('Copied timestamp to clipboard'));
      }
    }

    // --- YouTube player integration for timestamp capture ---
    let ytPlayer = null;
    function setupYouTubePlayer(videoId) {
      // If YouTube IFrame API not loaded, dynamic load
      if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
        const tag = document.createElement('script');
        tag.src = 'https://www.youtube.com/iframe_api';
        document.head.appendChild(tag);
      }

      // Create or replace iframe with enablejsapi=1
      const embed = document.querySelector('.player-embed iframe');
      if (embed) {
        const src = embed.src;
        if (!/enablejsapi=1/.test(src)) {
          embed.src = src + (src.indexOf('?') === -1 ? '?' : '&') + 'enablejsapi=1';
        }
        embed.id = 'ytPlayerIframe';
      }

      // Poll for YT availability then create player
      const tryCreate = () => {
        if (typeof YT !== 'undefined' && typeof YT.Player !== 'undefined') {
          if (ytPlayer) ytPlayer.destroy();
          ytPlayer = new YT.Player('ytPlayerIframe', {
            events: {
              onReady: () => {
                const controls = document.getElementById('playerControls');
                if (controls) controls.innerHTML = `<div style="display:flex;gap:0.5rem"><button class="search-btn" onclick="captureYouTubeTime()">Capture Time</button><button class="search-btn" onclick="insertCurrentTimeIntoEditorYT()">Insert Current</button></div>`;
              }
            }
          });
        } else {
          setTimeout(tryCreate, 300);
        }
      };
      tryCreate();
    }

    function captureYouTubeTime() {
      if (!ytPlayer) return alert('YouTube player not ready');
      const t = ytPlayer.getCurrentTime();
      const stamp = formatTimestamp(t);
      promptInsertOrCopy(stamp);
    }

    function insertCurrentTimeIntoEditorYT() {
      if (!ytPlayer) return alert('YouTube player not ready');
      const t = ytPlayer.getCurrentTime();
      const stamp = formatTimestamp(t);
      insertAtCursor(document.getElementById('lyricsEditor'), stamp + '\n');
    }
    
    // Switch Song Info Source
    function switchSongInfoSource(source) {
      currentSongInfoSource = source;
      document.querySelectorAll('.song-info-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.source === source);
      });
      
      if (currentSongInfo) {
        // Always pass the Spotify track ID if available, regardless of source
        // Stats.fm will use it, Tunebat will ignore it
        loadSongInfo(currentSongInfo.title, currentSongInfo.artist, source, currentSpotifyId);
      }
    }
    
    // Load Song Info
    async function loadSongInfo(title, artist, source = 'tunebat', spotifyId = null) {
      const songInfoSection = document.getElementById('songInfoSection');
      const songInfoContent = document.getElementById('songInfoContent');
      
      songInfoSection.style.display = 'block';
      songInfoContent.innerHTML = '<div class="song-info-loading">Loading song info...</div>';
      
      try {
        let data = null;
        
        if (source === 'statsfm') {
          // Stats.fm requires Spotify track ID - use it if available
          if (spotifyId) {
            data = await fetchStatsFmInfo(title, artist, spotifyId);
          } else {
            // If no Spotify ID but Stats.fm selected, try to find it or show error
            songInfoContent.innerHTML = '<div class="song-info-error">Stats.fm requires Spotify track. Please select a Spotify track or switch to Tunebat.</div>';
            return;
          }
        } else {
          // Tunebat can use Spotify ID if available, or search by title/artist
          data = await fetchTunebatInfo(title, artist, spotifyId);
        }
        
        if (data && !data.error) {
          displaySongInfo(data);
        } else {
          // If Stats.fm fails and we have Spotify ID, suggest trying Tunebat
          const errorMsg = source === 'statsfm' && spotifyId 
            ? `${data?.error || 'Stats.fm data unavailable. Try switching to Tunebat.'}`
            : `${data?.error || 'Song info not found. Try switching sources.'}`;
          songInfoContent.innerHTML = `<div class="song-info-error">${errorMsg}</div>`;
        }
      } catch (error) {
        console.error('Song info fetch error:', error);
        songInfoContent.innerHTML = '<div class="song-info-error">Error loading song info. Please try again.</div>';
      }
    }
    
    // Fetch Tunebat Info
    async function fetchTunebatInfo(title, artist, spotifyId = null) {
      try {
        let url = `/api/tunebat?title=${encodeURIComponent(title)}&artist=${encodeURIComponent(artist)}`;
        if (spotifyId) {
          url += `&spotifyId=${spotifyId}`;
        }
        const response = await fetch(url);
        
        if (response.ok) {
          return await response.json();
        }
        return { error: 'Tunebat API unavailable' };
      } catch (error) {
        console.error('Tunebat fetch error:', error);
        return { error: 'Failed to fetch from Tunebat' };
      }
    }
    
    // Fetch Stats.fm Info
    async function fetchStatsFmInfo(title, artist, spotifyId) {
      try {
        // Always include spotifyId in URL, even if null/undefined (API will handle it)
        let url = `/api/statsfm?title=${encodeURIComponent(title)}&artist=${encodeURIComponent(artist)}`;
        if (spotifyId) {
          url += `&spotifyId=${encodeURIComponent(spotifyId)}`;
        }
        
        console.log('Fetching Stats.fm with:', { title, artist, spotifyId, url });
        const response = await fetch(url);
        
        if (response.ok) {
          const data = await response.json();
          console.log('Stats.fm response:', data);
          return data;
        }
        const errorData = await response.json().catch(() => ({ error: 'Stats.fm data unavailable' }));
        return errorData;
      } catch (error) {
        console.error('Stats.fm fetch error:', error);
        return { error: 'Failed to fetch from Stats.fm: ' + error.message };
      }
    }
    
    // Display Song Info
    function displaySongInfo(data) {
      const songInfoContent = document.getElementById('songInfoContent');
      
      const infoItems = [];
      
      if (data.bpm || data.tempo) {
        infoItems.push({
          label: 'BPM',
          value: Math.round(data.bpm || data.tempo || 0),
          large: true
        });
      }
      
      if (data.key) {
        infoItems.push({
          label: 'Key',
          value: data.key,
          large: true
        });
      }
      
      if (data.energy !== undefined) {
        infoItems.push({
          label: 'Energy',
          value: `${data.energy}%`,
          progress: data.energy
        });
      }
      
      if (data.danceability !== undefined) {
        infoItems.push({
          label: 'Danceability',
          value: `${data.danceability}%`,
          progress: data.danceability
        });
      }
      
      if (data.valence !== undefined) {
        infoItems.push({
          label: 'Valence',
          value: `${data.valence}%`,
          progress: data.valence
        });
      }
      
      if (data.acousticness !== undefined) {
        infoItems.push({
          label: 'Acousticness',
          value: `${data.acousticness}%`,
          progress: data.acousticness
        });
      }
      
      if (data.instrumentalness !== undefined) {
        infoItems.push({
          label: 'Instrumental',
          value: `${data.instrumentalness}%`,
          progress: data.instrumentalness
        });
      }
      
      if (data.liveness !== undefined) {
        infoItems.push({
          label: 'Liveness',
          value: `${data.liveness}%`,
          progress: data.liveness
        });
      }
      
      if (data.speechiness !== undefined) {
        infoItems.push({
          label: 'Speechiness',
          value: `${data.speechiness}%`,
          progress: data.speechiness
        });
      }
      
      if (data.timeSignature) {
        infoItems.push({
          label: 'Time Sig',
          value: `${data.timeSignature}/4`
        });
      }
      
      if (data.popularity !== undefined) {
        infoItems.push({
          label: 'Popularity',
          value: `${data.popularity}%`,
          progress: data.popularity
        });
      }
      
      if (data.duration) {
        const minutes = Math.floor(data.duration / 60000);
        const seconds = Math.floor((data.duration % 60000) / 1000);
        infoItems.push({
          label: 'Duration',
          value: `${minutes}:${seconds.toString().padStart(2, '0')}`
        });
      }
      
      if (infoItems.length === 0) {
        songInfoContent.innerHTML = '<div class="song-info-error">No song data available</div>';
        return;
      }
      
      const html = `
        <div class="song-info-grid">
          ${infoItems.map(item => `
            <div class="song-info-item">
              <div class="song-info-label">${item.label}</div>
              <div class="song-info-value ${item.large ? 'song-info-value-large' : ''}">${item.value}</div>
              ${item.progress !== undefined ? `
                <div class="progress-bar">
                  <div class="progress-fill" style="width: ${item.progress}%"></div>
                </div>
              ` : ''}
            </div>
          `).join('')}
</div>
      `;
      
      songInfoContent.innerHTML = html;
    }
    
    // Switch Lyrics Source
    function switchLyricsSource(source) {
      currentLyricsSource = source;
      document.querySelectorAll('.lyrics-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.source === source);
      });
      
      if (currentSongInfo) {
        loadLyrics(currentSongInfo.title, currentSongInfo.artist, source);
      }
    }
    
    // Load Lyrics
    async function loadLyrics(title, artist, source = 'best') {
      const lyricsSection = document.getElementById('lyricsSection');
      const lyricsContent = document.getElementById('lyricsContent');
      const lyricsSource = document.getElementById('lyricsSource');
      
      lyricsSection.style.display = 'block';
      lyricsContent.innerHTML = '<div class="lyrics-loading">Loading lyrics...</div>';
      
      try {
        let lyrics = null;
        let sourceName = '';
        
        if (source === 'best') {
          const result = await fetchBestLyrics(title, artist);
          if (result && result.lyrics) {
            lyrics = result.lyrics;
            sourceName = result.source;
            lyricsSource.textContent = `Best from ${result.source}`;
          } else {
            lyricsContent.innerHTML = '<div class="lyrics-error">No lyrics found from any source. Try individual sources.</div>';
            return;
          }
        } else if (source === 'genius') {
          lyrics = await fetchGeniusLyrics(title, artist);
          sourceName = 'Genius';
          lyricsSource.textContent = 'Genius';
        } else {
          lyrics = await fetchLRCLibLyrics(title, artist);
          sourceName = 'LRCLib';
          lyricsSource.textContent = 'LRCLib';
        }
        
        if (lyrics) {
          setupLyricsEditor(lyrics, sourceName || 'Lyrics');
        } else {
          lyricsContent.innerHTML = '<div class="lyrics-error">Lyrics not found. Try switching sources.</div>';
        }
      } catch (error) {
        console.error('Lyrics fetch error:', error);
        lyricsContent.innerHTML = '<div class="lyrics-error">Error loading lyrics. Please try again.</div>';
      }
    }
    
    // Fetch Best Lyrics
    async function fetchBestLyrics(title, artist) {
      try {
        const response = await fetch(
          `/api/best-lyrics?title=${encodeURIComponent(title)}&artist=${encodeURIComponent(artist)}`
        );
        
        if (response.ok) {
          const data = await response.json();
          if (data.lyrics) {
            return data;
          }
        }
        return null;
      } catch (error) {
        console.error('Best lyrics fetch error:', error);
        return null;
      }
    }
    
    // Fetch Genius Lyrics
    async function fetchGeniusLyrics(title, artist) {
      try {
        // Use server-side API endpoint
        const response = await fetch(
          `/api/genius-lyrics?title=${encodeURIComponent(title)}&artist=${encodeURIComponent(artist)}`
        );
        
        if (response.ok) {
          const data = await response.json();
          if (data.url) {
            // For now, return a link. Full lyrics scraping would require server-side implementation
            return `Lyrics available on Genius:\n${data.url}\n\nNote: Full lyrics display requires Genius API access token in environment variables.`;
          }
        }
        
        // Fallback to LRCLib
        return await fetchLRCLibLyrics(title, artist);
      } catch (error) {
        console.error('Genius fetch error:', error);
        // Fallback to LRCLib
        return await fetchLRCLibLyrics(title, artist);
      }
    }
    
    // Fetch LRCLib Lyrics
    async function fetchLRCLibLyrics(title, artist) {
      try {
        // Clean song title and artist for better matching
        const cleanTitle = title.replace(/\([^)]*\)/g, '').trim();
        const cleanArtist = artist.split(',')[0].trim();
        
        // Try LRCLib API
        const searchQuery = `${cleanTitle} ${cleanArtist}`;
        const response = await fetch(
          `https://lrclib.net/api/search?q=${encodeURIComponent(searchQuery)}&limit=1`
        );
        
        if (response.ok) {
          const data = await response.json();
          if (data && data.length > 0 && data[0].syncedLyrics) {
            // Return synced lyrics
            const lyrics = data[0].syncedLyrics;
            // Format synced lyrics (remove timestamps for display or show them)
            const formattedLyrics = lyrics
              .replace(/\[(\d{2}):(\d{2})\.(\d{2,3})\]/g, '') // Remove timestamps
              .trim();
            return formattedLyrics || data[0].plainLyrics || 'Lyrics found but empty.';
          } else if (data && data.length > 0 && data[0].plainLyrics) {
            return data[0].plainLyrics;
          }
        }
        
        // Try alternative: search by track name only
        const titleOnlyResponse = await fetch(
          `https://lrclib.net/api/search?q=${encodeURIComponent(cleanTitle)}&limit=3`
        );
        
        if (titleOnlyResponse.ok) {
          const titleData = await titleOnlyResponse.json();
          if (titleData && titleData.length > 0) {
            // Find best match by artist
            const match = titleData.find(track => 
              track.artistName && track.artistName.toLowerCase().includes(cleanArtist.toLowerCase())
            ) || titleData[0];
            
            if (match.plainLyrics) {
              return match.plainLyrics;
            } else if (match.syncedLyrics) {
              return match.syncedLyrics.replace(/\[(\d{2}):(\d{2})\.(\d{2,3})\]/g, '').trim();
            }
          }
        }
        
        return null;
      } catch (error) {
        console.error('LRCLib fetch error:', error);
        return null;
      }
    }

    // Spotify Login
function login() {
  window.location.href = "/api/login";
}

// --- Lyrics editor helpers ---
function setupLyricsEditor(text, sourceName) {
  const lyricsContent = document.getElementById('lyricsContent');
  const html = `
    <div class="lyrics-editor-toolbar">
      <button class="search-btn" onclick="promptInsertTimestamp()">Insert Timestamp</button>
      <button class="search-btn" onclick="runChecks()">Run Checks</button>
      <button class="search-btn" onclick="exportReport()">Export Report</button>
      <button class="search-btn" onclick="toggleNotesView()">Toggle Notes</button>
      <div style="margin-left:auto;color:var(--text-secondary);padding:0.5rem 0.75rem;border-radius:8px;background:transparent;">${sourceName}</div>
    </div>
    <div class="editor-wrap">
      <div id="lyricsOverlay" class="lyrics-overlay" aria-hidden="true"></div>
      <textarea id="lyricsEditor" class="lyrics-editor-textarea"></textarea>
    </div>
    <div id="checkReport" class="check-report" style="display:none"></div>
  `;
  lyricsContent.innerHTML = html;
  const ta = document.getElementById('lyricsEditor');
  ta.value = text;
  loadNotesForEditor();
  // attach overlay syncing and live-checks
  const overlay = document.getElementById('lyricsOverlay');
  function syncScroll() {
    if (overlay) overlay.scrollTop = ta.scrollTop;
  }
  ta.addEventListener('scroll', syncScroll);
  ta.addEventListener('input', debounce(() => runChecks(), 400));
  // render initial checks and overlay
  runChecks();
}

function promptInsertTimestamp() {
  // Prompt for time (seconds or mm:ss[.xx]) and insert formatted [mm:ss.xx]
  const input = prompt('Enter time (seconds or mm:ss[.xx]):');
  if (!input) return;
  const seconds = parseTimeInput(input);
  if (isNaN(seconds)) {
    alert('Could not parse time. Use seconds or mm:ss[.xx]');
    return;
  }
  const stamp = formatTimestamp(seconds);
  insertAtCursor(document.getElementById('lyricsEditor'), stamp + '\n');
}

function parseTimeInput(s) {
  s = s.trim();
  if (/^\d+:/.test(s)) {
    const parts = s.split(':');
    const mm = parseInt(parts[0], 10);
    const ss = parseFloat(parts[1]);
    return mm * 60 + ss;
  }
  return parseFloat(s);
}

function formatTimestamp(seconds) {
  const mm = Math.floor(seconds / 60);
  const ss = Math.floor(seconds % 60);
  const xx = Math.floor((seconds - Math.floor(seconds)) * 100).toString().padStart(2, '0');
  return `[${mm.toString().padStart(2,'0')}:${ss.toString().padStart(2,'0')}.${xx}]`;
}

function insertAtCursor(el, text) {
  const start = el.selectionStart || 0;
  const end = el.selectionEnd || 0;
  const value = el.value || '';
  el.value = value.slice(0, start) + text + value.slice(end);
  const pos = start + text.length;
  el.selectionStart = el.selectionEnd = pos;
  el.focus();
}

function runChecks() {
  const ta = document.getElementById('lyricsEditor');
  if (!ta) return;
  const text = ta.value;
  const lines = text.split(/\r?\n/);
  const report = [];
  const issues = [];

  // Line-length check
  const maxLen = 42;
  lines.forEach((ln, i) => {
    if (ln.trim().length === 0) return;
    if (ln.length > maxLen) {
      const msg = `Line ${i+1}: Too long (${ln.length} chars)`;
      report.push(msg);
      issues.push({ line: i+1, message: msg });
    }
  });

  // Repetition / structure: detect repeated multi-line blocks (chorus/verse)
  const blockMatches = [];
  const minBlock = 2; // minimum lines in a repeated block
  const maxBlock = 8; // max block length to check
  for (let size = maxBlock; size >= minBlock; size--) {
    const seen = {};
    for (let i = 0; i + size <= lines.length; i++) {
      const block = lines.slice(i, i + size).map(l => l.trim().toLowerCase()).join('\n');
      if (!block || /^\s*$/.test(block)) continue;
      seen[block] = seen[block] || [];
      seen[block].push(i+1);
    }
    Object.keys(seen).forEach(b => {
      if (seen[b].length > 1) {
        // record as a repeated block
        blockMatches.push({ size, occurrences: seen[b] });
        const msg = `Repeated ${size}-line block at starts: ${seen[b].join(', ')}`;
        report.push(msg);
        seen[b].forEach(n => issues.push({ line: n, message: `Repeated ${size}-line block (starts at ${seen[b].join(', ')})` }));
        // zero out lines in this block to avoid duplicate smaller-block reports
        seen[b].forEach(start => {
          for (let k = 0; k < size; k++) {
            const idx = start - 1 + k;
            if (idx >= 0 && idx < lines.length) lines[idx] = lines[idx];
          }
        });
      }
    });
  }

  // Proper-noun / capitalization check against a small dictionary
  // Proper-noun / capitalization detection
  const properNouns = ['Mumbai','India','Taylor','Beyonce','Ariana','Rihanna','Gandhi'];
  // Build a file-wide word capitalization map to find inconsistent usages
  const wordCaps = {};
  lines.forEach((ln, i) => {
    const words = ln.split(/[^A-Za-z\u00C0-\u024F'-]+/).filter(Boolean);
    words.forEach(w => {
      const key = w.toLowerCase();
      wordCaps[key] = wordCaps[key] || new Set();
      wordCaps[key].add(w);
    });
  });
  // Flag words that appear with inconsistent capitalization (e.g., "mumbai" and "Mumbai")
  Object.keys(wordCaps).forEach(k => {
    const variants = Array.from(wordCaps[k]);
    if (variants.length > 1) {
      // prefer Title Case as canonical suggestion
      const suggestion = variants.find(v => /^[A-Z][a-z]/.test(v)) || variants[0];
      // find all lines containing lowercase-only occurrences to warn
      lines.forEach((ln, i) => {
        const re = new RegExp(`\\b${k}\\b`, 'g');
        if (re.test(ln) && !new RegExp(`\\b${suggestion}\\b`).test(ln)) {
          const msg = `Line ${i+1}: Inconsistent capitalization for "${k}" (suggest "${suggestion}")`;
          report.push(msg);
          issues.push({ line: i+1, message: msg });
        }
      });
    }
  });
  // Also flag known proper nouns if present but lowercase
  lines.forEach((ln, i) => {
    properNouns.forEach(name => {
      const reLower = new RegExp(`\\b${name.toLowerCase()}\\b`);
      if (reLower.test(ln) && !new RegExp(`\\b${name}\\b`).test(ln)) {
        const msg = `Line ${i+1}: Proper noun "${name}" may be incorrectly capitalized`;
        report.push(msg);
        issues.push({ line: i+1, message: msg });
      }
    });
  });

  // Punctuation / question-mark
  const questionWords = /\b(what|why|how|when|where|who)\b/i;
  lines.forEach((ln, i) => {
    if (questionWords.test(ln) && !/\?$/.test(ln.trim())) {
      const msg = `Line ${i+1}: Looks like a question but missing '?'`;
      report.push(msg);
      issues.push({ line: i+1, message: msg });
    }
    if (/\.\.\./.test(ln) && !/\.\.\./.test(ln.trim())) {
      const msg = `Line ${i+1}: Inconsistent ellipses`;
      report.push(msg);
      issues.push({ line: i+1, message: msg });
    }
  });

  // Capitalization
  lines.forEach((ln, i) => {
    const trimmed = ln.trim();
    if (!trimmed) return;
    const first = trimmed.charAt(0);
    if (first === first.toLowerCase() && /[A-Za-z]/.test(first)) {
      const msg = `Line ${i+1}: Starts with lowercase letter`;
      report.push(msg);
      issues.push({ line: i+1, message: msg });
    }
  });

  // Script mixing detection (Latin + Indic/Cyrillic/Arabic ranges)
  const scriptChecks = [
    { name: 'Devanagari', re: /[\u0900-\u097F]/ },
    { name: 'Bengali', re: /[\u0980-\u09FF]/ },
    { name: 'Tamil', re: /[\u0B80-\u0BFF]/ },
    { name: 'Telugu', re: /[\u0C00-\u0C7F]/ },
    { name: 'Arabic', re: /[\u0600-\u06FF]/ },
    { name: 'Cyrillic', re: /[\u0400-\u04FF]/ }
  ];
  lines.forEach((ln, i) => {
    const hasLatin = /[A-Za-z]/.test(ln);
    const found = scriptChecks.filter(s => s.re.test(ln)).map(s => s.name);
    if (hasLatin && found.length > 0) {
      const msg = `Line ${i+1}: Mixed scripts (Latin + ${found.join('/')})`;
      report.push(msg);
      issues.push({ line: i+1, message: msg });
    }
  });

  // Syllable heuristic per line
  lines.forEach((ln, i) => {
    const syl = estimateSyllables(ln);
    if (syl > 18) {
      const msg = `Line ${i+1}: High syllable count (~${syl})`;
      report.push(msg);
      issues.push({ line: i+1, message: msg });
    }
  });

  // Readability heuristic: words per line and average word length
  lines.forEach((ln, i) => {
    const words = ln.trim().split(/\s+/).filter(Boolean);
    if (words.length === 0) return;
    const avgWordLen = words.reduce((s,w)=>s+w.replace(/[^A-Za-z]/g,'').length,0)/words.length;
    if (words.length > 10 || avgWordLen > 7) {
      const msg = `Line ${i+1}: Low readability (words:${words.length}, avgLen:${avgWordLen.toFixed(1)})`;
      report.push(msg);
      issues.push({ line: i+1, message: msg });
    }
  });

  // Show report
  const reportDiv = document.getElementById('checkReport');
  if (report.length === 0) {
    reportDiv.style.display = 'block';
    reportDiv.textContent = 'No major issues detected.';
  } else {
    reportDiv.style.display = 'block';
    reportDiv.innerHTML = '<strong>Reviewer-sim report:</strong><br>' + report.map(r => `- ${r}`).join('<br>');
  }

  // Populate clickable issues list for quick navigation
  const issuesDiv = document.getElementById('issuesList');
  if (issues.length === 0) {
    issuesDiv.style.display = 'none';
    issuesDiv.innerHTML = '';
  } else {
    issuesDiv.style.display = 'block';
    issuesDiv.innerHTML = '<strong>Issues (click to jump):</strong><br>' + issues.map(it => `<a href="#" onclick="goToLine(${it.line});return false;">Line ${it.line}: ${escapeHtml(it.message)}</a>`).join('<br>');
  }
  // render overlay highlights for current lines and issues
  try { renderOverlay(lines, issues); } catch(e) { console.warn('overlay render failed', e); }
}

function escapeHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function goToLine(n) {
  const ta = document.getElementById('lyricsEditor');
  if (!ta) return;
  const lines = ta.value.split(/\r?\n/);
  let pos = 0;
  for (let i=0;i<n-1 && i<lines.length;i++) pos += lines[i].length + 1;
  ta.focus();
  ta.selectionStart = ta.selectionEnd = pos;
  ta.scrollTop = Math.max(0, (n-3) * 20);
}

// Render overlay highlights for each line using issues
function renderOverlay(lines, issues) {
  const overlay = document.getElementById('lyricsOverlay');
  if (!overlay) return;
  overlay.innerHTML = lines.map((ln, i) => {
    const num = i+1;
    const has = issues.some(it => it.line === num);
    const safe = escapeHtml(ln) || '&nbsp;';
    return `<div class="line ${has? 'highlight':''}" data-line="${num}">${safe}</div>`;
  }).join('');
  const ta = document.getElementById('lyricsEditor');
  if (ta) overlay.scrollTop = ta.scrollTop;
}

function debounce(fn, wait) {
  let t = null;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), wait);
  };
}

function exportReport() {
  const reportDiv = document.getElementById('checkReport');
  const issuesDiv = document.getElementById('issuesList');
  const ta = document.getElementById('lyricsEditor');
  const text = ta ? ta.value : '';
  // Re-run checks to ensure latest
  runChecks();
  const reportHtml = reportDiv ? reportDiv.innerHTML : '';
  const issuesHtml = issuesDiv ? issuesDiv.innerHTML : '';
  const payload = {
    song: getSongKey(),
    lyrics: text,
    reportHtml,
    issuesHtml,
    timestamp: new Date().toISOString()
  };
  const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${getSongKey().replace(/[^a-z0-9-_]/gi,'_')}-review.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

// Demo helper to load sample lyrics so features are visible without API
function showDemo() {
  const sample = `[00:00.00] Demo Song - Artist
[00:05.20] Verse 1: I woke up this morning, the sun was bright
You know I felt the rhythm, moving through the night
What are you doing

[00:20.50] Chorus: Oh, oh, we sing again
Oh, oh, we sing again

[00:40.00] Verse 2: The city lights were calling my name
I walked the streets alone but I felt no pain
What are you doing

`;
  setupLyricsEditor(sample, 'Demo');
  // show the lyrics section and focus
  document.getElementById('lyricsSection').style.display = 'block';
  const ta = document.getElementById('lyricsEditor');
  if (ta) ta.focus();
}

function estimateSyllables(line) {
  if (!line) return 0;
  const words = line.split(/[^A-Za-z]+/).filter(Boolean);
  let total = 0;
  words.forEach(w => {
    const lw = w.toLowerCase();
    const vgroups = lw.replace(/e\b/, '').match(/[aeiouy]{1,2}/g);
    total += (vgroups ? vgroups.length : 1);
  });
  return total;
}

// Per-line notes stored in localStorage keyed by song title+artist (fallback to 'untitled')
function getSongKey() {
  if (currentSongInfo && currentSongInfo.title) {
    return `${currentSongInfo.title} - ${currentSongInfo.artist}`;
  }
  return 'untitled';
}

function saveNotesForEditor() {
  const ta = document.getElementById('lyricsEditor');
  if (!ta) return;
  const lines = ta.value.split(/\r?\n/);
  const notes = {};
  lines.forEach((ln, i) => {
    const m = ln.match(/\s*\{note:(.*)\}$/i);
    if (m) notes[i] = m[1].trim();
  });
  localStorage.setItem('lyricsNotes:' + getSongKey(), JSON.stringify(notes));
  alert('Notes saved locally');
}

function loadNotesForEditor() {
  const ta = document.getElementById('lyricsEditor');
  if (!ta) return;
  const raw = localStorage.getItem('lyricsNotes:' + getSongKey());
  if (!raw) return;
  const notes = JSON.parse(raw);
  const lines = ta.value.split(/\r?\n/);
  Object.keys(notes).forEach(idx => {
    const i = parseInt(idx, 10);
    if (i < lines.length) {
      // append note if not already present
      if (!/\{note:/i.test(lines[i])) lines[i] = lines[i] + ' {note:' + notes[idx] + '}';
    }
  });
  ta.value = lines.join('\n');
}

function toggleNotesView() {
  const ta = document.getElementById('lyricsEditor');
  if (!ta) return;
  // simple toggle: if any line has {note: show/hide by removing or restoring from storage
  const raw = localStorage.getItem('lyricsNotes:' + getSongKey());
  if (!raw) {
    // save existing inline notes to storage
    saveNotesForEditor();
    return;
  }
  // If notes exist in storage, remove inline notes from textarea
  const notes = JSON.parse(raw);
  const lines = ta.value.split(/\r?\n/);
  Object.keys(notes).forEach(idx => {
    const i = parseInt(idx, 10);
    if (i < lines.length) lines[i] = lines[i].replace(/\s*\{note:.*\}$/i, '').trimRight();
  });
  ta.value = lines.join('\n');
  localStorage.removeItem('lyricsNotes:' + getSongKey());
}

    // Spotify Search
async function spotifySearch() {
      const query = document.getElementById('sQuery').value.trim();
      if (!query) return;

      const sResults = document.getElementById('sResults');
      sResults.innerHTML = '<div class="player-placeholder">Searching...</div>';

      try {
        const tokenResponse = await fetch("/api/token");
        const tokenData = await tokenResponse.json();
        
        if (!tokenData.access_token) {
          sResults.innerHTML = '<div class="player-placeholder">Please login to Spotify first</div>';
          return;
        }

        const response = await fetch(
          `https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=10`,
          { headers: { Authorization: "Bearer " + tokenData.access_token } }
        );
        const data = await response.json();

  sResults.innerHTML = "";
        if (data.tracks && data.tracks.items.length > 0) {
          data.tracks.items.forEach(track => {
    const div = document.createElement("div");
            div.className = "result-item";
            div.innerHTML = `
              <div class="result-title">${track.name}</div>
              <div class="result-artist">${track.artists.map(a => a.name).join(', ')}</div>
            `;
            div.onclick = () => {
              const spotifyTrackId = track.id;
              console.log('Spotify track selected:', { id: spotifyTrackId, name: track.name, artist: track.artists.map(a => a.name).join(', ') });
              const embedHtml = `<iframe src="https://open.spotify.com/embed/track/${spotifyTrackId}" width="100%" height="152" frameborder="0" allowtransparency="true" allow="autoplay; encrypted-media"></iframe>`;
              // Use Spotify preview_url if available for timestamp capture
              updatePlayer(embedHtml, 'spotify', {
                title: track.name,
                artist: track.artists.map(a => a.name).join(', ')
              }, spotifyTrackId, track.preview_url || null);
            };
    sResults.appendChild(div);
  });
        } else {
          sResults.innerHTML = '<div class="player-placeholder">No results found</div>';
        }
      } catch (error) {
        sResults.innerHTML = '<div class="player-placeholder">Error searching. Please try again.</div>';
        console.error('Spotify search error:', error);
      }
    }

    // Apple Music Search
async function appleSearch() {
      const query = document.getElementById('aQuery').value.trim();
      if (!query) return;

      const aResults = document.getElementById('aResults');
      aResults.innerHTML = '<div class="player-placeholder">Searching...</div>';

      try {
        const response = await fetch(
          `https://itunes.apple.com/search?term=${encodeURIComponent(query)}&entity=song&limit=10`
        );
        const data = await response.json();

  aResults.innerHTML = "";
        if (data.results && data.results.length > 0) {
          data.results.forEach(track => {
    const div = document.createElement("div");
            div.className = "result-item";
            div.innerHTML = `
              <div class="result-title">${track.trackName}</div>
              <div class="result-artist">${track.artistName}</div>
            `;
    div.onclick = () => {
              const embedUrl = track.trackViewUrl.replace(
          "music.apple.com",
          "embed.music.apple.com"
              );
              const embedHtml = `<iframe src="${embedUrl}" width="100%" height="150" frameborder="0" allowtransparency="true" allow="autoplay; encrypted-media"></iframe>`;
              // iTunes API provides a previewUrl we can use
              updatePlayer(embedHtml, 'apple', {
                title: track.trackName,
                artist: track.artistName
              }, null, track.previewUrl || null);
    };
    aResults.appendChild(div);
  });
        } else {
          aResults.innerHTML = '<div class="player-placeholder">No results found</div>';
        }
      } catch (error) {
        aResults.innerHTML = '<div class="player-placeholder">Error searching. Please try again.</div>';
        console.error('Apple Music search error:', error);
      }
    }

    // YouTube Search
async function youtubeSearch() {
      const query = document.getElementById('yQuery').value.trim();
      if (!query) return;

      const yResults = document.getElementById('yResults');
      yResults.innerHTML = '<div class="player-placeholder">Searching...</div>';

      try {
        const response = await fetch(
          `/api/youtube-search?q=${encodeURIComponent(query)}`
        );
        const data = await response.json();

  yResults.innerHTML = "";
        if (data.items && data.items.length > 0) {
          data.items.forEach(video => {
    const div = document.createElement("div");
            div.className = "result-item";
            div.innerHTML = `
              <div class="result-title">${video.snippet.title}</div>
              <div class="result-artist">${video.snippet.channelTitle}</div>
            `;
    div.onclick = () => {
              // Use enablejsapi=1 for YouTube iframe to allow timestamp capture
              const embedHtml = `<iframe width="100%" height="220" src="https://www.youtube.com/embed/${video.id.videoId}?enablejsapi=1" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>`;
              // Extract artist from title if possible (common format: "Song Name - Artist")
              const titleParts = video.snippet.title.split(' - ');
              updatePlayer(embedHtml, 'youtube', {
                title: titleParts[0] || video.snippet.title,
                artist: titleParts[1] || video.snippet.channelTitle
              }, null, null, { youtubeId: video.id.videoId });
    };
    yResults.appendChild(div);
  });
        } else {
          yResults.innerHTML = '<div class="player-placeholder">No results found</div>';
        }
      } catch (error) {
        yResults.innerHTML = '<div class="player-placeholder">Error searching. Please try again.</div>';
        console.error('YouTube search error:', error);
      }
}
</script>
</body>
</html>
