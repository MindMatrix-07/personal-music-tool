<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Personal Music Tool</title>

  <style>
    :root {
      /* Light Mode */
      --bg-primary: #ffffff;
      --bg-secondary: #f8f9fa;
      --bg-card: #ffffff;
      --bg-input: #f1f3f5;
      --text-primary: #212529;
      --text-secondary: #6c757d;
      --border-color: #dee2e6;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.15);

      /* Platform Colors */
      --spotify-green: #1db954;
      --spotify-green-hover: #1ed760;
      --apple-red: #fa243c;
      --apple-red-hover: #ff3b5c;
      --youtube-red: #ff0000;
      --youtube-red-hover: #ff1a1a;

      /* Transitions */
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    [data-theme="dark"] {
      /* Dark Mode */
      --bg-primary: #0f0f0f;
      --bg-secondary: #1a1a1a;
      --bg-card: #1e1e1e;
      --bg-input: #2a2a2a;
      --text-primary: #ffffff;
      --text-secondary: #b3b3b3;
      --border-color: #333333;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4);
      --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.5);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      transition: var(--transition);
      min-height: 100vh;
      line-height: 1.6;
    }

    /* Top Bar */
    .top-bar {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow-sm);
    }

    .top-bar-left {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .platform-tab {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      color: white;
      position: relative;
      overflow: hidden;
    }

    .platform-tab::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.2);
      transition: left 0.3s;
    }

    .platform-tab:hover::before {
      left: 100%;
    }

    .platform-tab.active {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .platform-tab.spotify {
      background: var(--spotify-green);
    }

    .platform-tab.spotify:hover {
      background: var(--spotify-green-hover);
    }


    .platform-tab.apple {
      background: var(--apple-red);
    }

    .platform-tab.apple:hover {
      background: var(--apple-red-hover);
    }

    .platform-tab.youtube {
      background: var(--youtube-red);
    }

    .platform-tab.youtube:hover {
      background: var(--youtube-red-hover);
    }

    .theme-toggle {
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.2rem;
      transition: var(--transition);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .theme-toggle:hover {
      background: var(--bg-input);
      transform: scale(1.05);
    }

    /* Main Layout */
    .main-container {
      display: grid;
      grid-template-columns: 1fr 380px;
      gap: 2rem;
      padding: 2rem;
      max-width: 1600px;
      margin: 0 auto;
    }

    /* Left Column - Search Area */
    .search-area {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }


    .player-embed-container {
      width: 100%;
      height: 450px;
      border-radius: 12px;
      overflow: hidden;
      display: none;
    }

    .player-embed-container iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    .search-panel {
      display: none;
      animation: fadeIn 0.3s ease-in;
    }

    .search-panel.active {
      display: block;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .search-card {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: var(--shadow-md);
      border: 1px solid var(--border-color);
    }

    .search-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1.5rem;
    }

    .search-header h2 {
      font-size: 1.5rem;
      font-weight: 700;
    }

    .spotify-login-btn {
      background: var(--spotify-green);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      font-size: 0.9rem;
    }

    .spotify-login-btn:hover {
      background: var(--spotify-green-hover);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    /* Apple Login Button Removed - Using Embeds */

    .search-input-group {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }

    .search-input {
      flex: 1;
      padding: 0.875rem 1rem;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      background: var(--bg-input);
      color: var(--text-primary);
      font-size: 1rem;
      transition: var(--transition);
    }

    .search-input:focus {
      outline: none;
      border-color: var(--spotify-green);
      box-shadow: 0 0 0 3px rgba(29, 185, 84, 0.1);
    }

    .search-btn {
      padding: 0.875rem 1.5rem;
      border: none;
      border-radius: 12px;
      background: var(--spotify-green);
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      font-size: 1rem;
    }

    .search-btn:hover {
      background: var(--spotify-green-hover);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }

    .search-btn.apple {
      background: var(--apple-red);
    }

    .search-btn.apple:hover {
      background: var(--apple-red-hover);
    }

    .search-btn.youtube {
      background: var(--youtube-red);
    }

    .search-btn.youtube:hover {
      background: var(--youtube-red-hover);
    }

    .results-container {
      margin-top: 1rem;
    }

    .result-item {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 0.75rem;
      cursor: pointer;
      transition: var(--transition);
    }

    .result-item:hover {
      background: var(--bg-input);
      transform: translateX(4px);
      box-shadow: var(--shadow-sm);
      border-color: var(--spotify-green);
    }

    .result-title {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
      font-size: 1rem;
    }

    .result-artist {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    /* Right Column - Player Card */
    .player-card {
      position: sticky;
      top: 100px;
      background: var(--bg-card);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: var(--shadow-lg);
      border: 1px solid var(--border-color);
      height: fit-content;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
    }

    .player-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1rem;
    }

    .player-title {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text-primary);
    }

    .platform-badge {
      padding: 0.35rem 0.75rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .platform-badge.spotify {
      background: var(--spotify-green);
      color: white;
    }

    .platform-badge.apple {
      background: var(--apple-red);
      color: white;
    }

    .platform-badge.youtube {
      background: var(--youtube-red);
      color: white;
    }

    .player-content {
      min-height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 1rem;
    }

    .player-placeholder {
      text-align: center;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .player-embed {
      width: 100%;
      border-radius: 12px;
      overflow: hidden;
    }

    .player-embed iframe {
      width: 100%;
      border: none;
      border-radius: 12px;
    }

    /* Lyrics Section */
    .lyrics-section {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px solid var(--border-color);
    }

    .lyrics-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1rem;
    }

    .lyrics-title {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-primary);
    }

    .lyrics-source {
      font-size: 0.75rem;
      color: var(--text-secondary);
      padding: 0.25rem 0.5rem;
      background: var(--bg-secondary);
      border-radius: 12px;
    }

    .lyrics-content {
      max-height: 400px;
      overflow-y: auto;
      padding: 1rem;
      background: var(--bg-secondary);
      border-radius: 12px;
      font-size: 0.95rem;
      line-height: 1.8;
      color: var(--text-primary);
      white-space: pre-wrap;
      text-align: left;
    }

    .lyrics-loading {
      text-align: center;
      color: var(--text-secondary);
      padding: 2rem;
      font-size: 0.9rem;
    }

    .lyrics-error {
      text-align: center;
      color: var(--text-secondary);
      padding: 1rem;
      font-size: 0.9rem;
    }

    .lyrics-tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    /* Playback Controls Bar */
    .playback-controls-bar {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .playback-progress-container {
      margin-bottom: 0.75rem;
    }

    .playback-progress {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--bg-input);
      border-radius: 3px;
      outline: none;
      cursor: pointer;
    }

    .playback-progress::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: var(--spotify-green);
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s;
    }

    .playback-progress::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      background: var(--spotify-green-hover);
    }

    .playback-progress::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: var(--spotify-green);
      border-radius: 50%;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
    }

    .playback-progress::-moz-range-thumb:hover {
      transform: scale(1.2);
      background: var(--spotify-green-hover);
    }

    .playback-time {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-top: 0.5rem;
    }

    .playback-buttons {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
    }

    .playback-btn {
      padding: 0.5rem 1rem;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: var(--transition);
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .playback-btn:hover {
      background: var(--bg-input);
      border-color: var(--spotify-green);
      transform: translateY(-2px);
    }

    .playback-btn.active {
      background: var(--spotify-green);
      color: white;
      border-color: var(--spotify-green);
    }

    /* Lyrics Editor */
    .lyrics-editor-container {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .lyrics-editor-textarea {
      width: 100%;
      min-height: 300px;
      max-height: 600px;
      resize: vertical;
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      font-size: 0.95rem;
      line-height: 1.6;
      font-family: inherit;
    }

    .lyrics-editor-toolbar {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .lyrics-tab {
      padding: 0.5rem 1rem;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-primary);
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: var(--transition);
    }

    .lyrics-tab.active {
      background: var(--spotify-green);
      color: white;
      border-color: var(--spotify-green);
    }

    .lyrics-tab:hover {
      background: var(--bg-input);
    }

    /* Song Info Section */
    .song-info-section {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px solid var(--border-color);
    }

    .song-info-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1rem;
    }

    .song-info-title {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-primary);
    }

    .song-info-tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .song-info-tab {
      padding: 0.5rem 1rem;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-primary);
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: var(--transition);
    }

    .song-info-tab.active {
      background: var(--spotify-green);
      color: white;
      border-color: var(--spotify-green);
    }

    .song-info-tab:hover {
      background: var(--bg-input);
    }

    .song-info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.75rem;
    }

    .song-info-item {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 1rem;
      text-align: center;
      transition: var(--transition);
    }

    .song-info-item:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-sm);
      border-color: var(--spotify-green);
    }

    .song-info-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    .song-info-value {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--text-primary);
    }

    .song-info-value-large {
      font-size: 1.5rem;
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: var(--bg-input);
      border-radius: 3px;
      overflow: hidden;
      margin-top: 0.5rem;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--spotify-green), var(--spotify-green-hover));
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    .song-info-loading {
      text-align: center;
      color: var(--text-secondary);
      padding: 2rem;
      font-size: 0.9rem;
    }

    .song-info-error {
      text-align: center;
      color: var(--text-secondary);
      padding: 1rem;
      font-size: 0.9rem;
    }

    /* Responsive Design */
    @media (max-width: 1024px) {
      .main-container {
        grid-template-columns: 1fr;
      }

      .player-card {
        position: relative;
        top: 0;
        max-height: none;
      }
    }

    @media (max-width: 768px) {
      html {
        font-size: 16px;
        /* Prevent zoom by using proper base font size */
        -webkit-text-size-adjust: 100%;
        -ms-text-size-adjust: 100%;
      }

      body {
        font-size: 16px;
        /* Ensure readable text without zoom */
      }

      .top-bar {
        padding: 0.75rem 1rem;
        flex-wrap: wrap;
      }

      .top-bar-left {
        width: 100%;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .platform-tab {
        flex: 1;
        min-width: 0;
        padding: 0.65rem 0.75rem;
        font-size: 0.8rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .theme-toggle {
        padding: 0.4rem 0.75rem;
        font-size: 1rem;
      }

      .theme-toggle span:last-child {
        display: none;
        /* Hide text on mobile, show only icon */
      }

      .main-container {
        padding: 1rem 0.75rem;
        gap: 1.25rem;
      }

      .search-card {
        padding: 1.25rem 1rem;
      }

      .search-header h2 {
        font-size: 1.25rem;
      }

      .search-input {
        font-size: 16px;
        /* Prevent iOS zoom on input focus */
        padding: 0.75rem 0.875rem;
      }

      .search-btn {
        padding: 0.75rem 1.25rem;
        font-size: 0.95rem;
      }

      .player-card {
        padding: 1.25rem 1rem;
      }

      .player-title {
        font-size: 1rem;
      }

      .result-item {
        padding: 0.875rem;
      }

      .result-title {
        font-size: 0.95rem;
      }

      .result-artist {
        font-size: 0.85rem;
      }

      .lyrics-content {
        max-height: 300px;
        font-size: 0.9rem;
        padding: 0.875rem;
      }

      .lyrics-tabs {
        flex-wrap: wrap;
      }

      .lyrics-tab {
        flex: 1;
        min-width: 80px;
        padding: 0.4rem 0.75rem;
        font-size: 0.8rem;
      }

      .song-info-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem;
      }

      .song-info-item {
        padding: 0.75rem;
      }

      .song-info-value {
        font-size: 1.1rem;
      }

      .song-info-value-large {
        font-size: 1.3rem;
      }

      .song-info-tabs {
        flex-wrap: wrap;
      }

      .song-info-tab {
        flex: 1;
        min-width: 80px;
        padding: 0.4rem 0.75rem;
        font-size: 0.8rem;
      }
    }

    @media (max-width: 480px) {
      .top-bar {
        padding: 0.625rem 0.75rem;
      }

      .platform-tab {
        padding: 0.55rem 0.5rem;
        font-size: 0.75rem;
      }

      .main-container {
        padding: 0.75rem 0.5rem;
        gap: 1rem;
      }

      .search-card {
        padding: 1rem 0.875rem;
      }

      .player-card {
        padding: 1rem 0.875rem;
      }
    }

    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-secondary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-secondary);
    }
  </style>
</head>

<body>
  <!-- Top Bar -->
  <div class="top-bar">
    <div class="top-bar-left">
      <button class="platform-tab spotify active" data-platform="spotify">
        üéµ Spotify
      </button>
      <button class="platform-tab apple" data-platform="apple">
        üçé Apple Music
      </button>
      <button class="platform-tab youtube" data-platform="youtube">
        ‚ñ∂Ô∏è YouTube
      </button>
    </div>
    <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
      <span id="themeIcon">üåô</span>
      <span id="themeText">Dark</span>
    </button>
  </div>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Left Column - Search Area -->
    <div class="search-area">
      <!-- Spotify Search Panel -->
      <div class="search-panel active" id="spotifyPanel">
        <div class="search-card">
          <div class="search-header">
            <h2>Spotify Search</h2>
            <div style="display: flex; align-items: center; gap: 10px;">
              <span id="spotifyUserStatus"
                style="font-size: 0.8rem; display: none; color: var(--text-secondary);"></span>
              <button id="spotifyLoginBtn" class="spotify-login-btn" onclick="login()">Login</button>
            </div>
          </div>
          <div class="search-input-group">
            <input type="text" id="sQuery" class="search-input" placeholder="Search for songs, artists, albums..."
              onkeypress="if(event.key === 'Enter') spotifySearch()">
            <button class="search-btn" onclick="spotifySearch()">Search</button>
          </div>
          <div class="results-container" id="sResults"></div>
        </div>
      </div>

      <!-- Apple Music Search Panel -->
      <div class="search-panel" id="applePanel">
        <div class="search-card">
          <div class="search-header">
            <h2>Apple Music Search</h2>
            <div style="display: flex; align-items: center; gap: 10px;">
              <span id="appleUserStatus" style="font-size: 0.8rem; display: none; color: var(--text-secondary);"></span>
              <button id="appleLoginBtn" class="apple-login-btn" onclick="appleLogin()">Login</button>
            </div>
          </div>
          <div class="search-input-group">
            <input type="text" id="aQuery" class="search-input" placeholder="Search for songs, artists, albums..."
              onkeypress="if(event.key === 'Enter') appleSearch()">
            <button class="search-btn apple" onclick="appleSearch()">Search</button>
          </div>
          <div class="results-container" id="aResults"></div>
        </div>
      </div>

      <!-- YouTube Search Panel -->
      <div class="search-panel" id="youtubePanel">
        <div class="search-card">
          <div class="search-header">
            <h2>YouTube Search</h2>
          </div>
          <div class="search-input-group">
            <input type="text" id="yQuery" class="search-input" placeholder="Search for songs, videos..."
              onkeypress="if(event.key === 'Enter') youtubeSearch()">
            <button class="search-btn youtube" onclick="youtubeSearch()">Search</button>
          </div>
          <div class="results-container" id="yResults"></div>
        </div>
      </div>
    </div>

    <!-- Right Column - Player Card -->
    <div class="player-card">
      <div class="player-header">
        <div class="player-title">Now Playing</div>
        <div class="platform-badge" id="playerBadge" style="display: none;">Spotify</div>
      </div>
      <div class="player-content" id="player">
        <div class="player-placeholder">
          Select a song to start playing
        </div>
      </div>

      <!-- Song Info Section -->
      <div class="song-info-section" id="songInfoSection" style="display: none;">
        <div class="song-info-header">
          <div class="song-info-title">Song Analysis</div>
        </div>
        <div class="song-info-tabs">
          <button class="song-info-tab active" data-source="apple" onclick="switchSongInfoSource('apple')">Apple
            Music</button>
          <button class="song-info-tab" data-source="spotify" onclick="switchSongInfoSource('spotify')">Spotify</button>
        </div>
        <div class="song-info-content" id="songInfoContent">
          <div class="song-info-loading">Loading song info...</div>
        </div>
      </div>

      <!-- Lyrics Section -->
      <div class="lyrics-section" id="lyricsSection" style="display: none;">
        <div class="lyrics-header">
          <div class="lyrics-title">Lyrics</div>
          <div class="lyrics-source" id="lyricsSource"></div>
        </div>
        <div class="lyrics-tabs">
          <button class="lyrics-tab" data-source="best" onclick="switchLyricsSource('best')">Best Lyrics</button>
          <button class="lyrics-tab" data-source="genius" onclick="switchLyricsSource('genius')">Genius</button>
          <button class="lyrics-tab" data-source="lrclib" onclick="switchLyricsSource('lrclib')">LRCLib</button>
          <button class="lyrics-tab" data-source="write" onclick="switchLyricsSource('write')">Write</button>
        </div>

        <!-- Playback Controls Bar -->
        <div class="playback-controls-bar" id="playbackControlsBar" style="display: none;">
          <div class="playback-progress-container">
            <input type="range" id="playbackProgress" class="playback-progress" min="0" max="100" value="0" step="0.1">
            <div class="playback-time">
              <span id="currentTime">0:00</span> / <span id="totalTime">0:00</span>
            </div>
          </div>
          <div class="playback-buttons">
            <button class="playback-btn" onclick="rewind10s()" title="Rewind 10 seconds">‚è™ 10s</button>
            <button class="playback-btn" id="pauseBtn" onclick="togglePause()" title="Pause/Play">
              <span id="pauseIcon">‚è∏Ô∏è</span>
            </button>
            <button class="playback-btn" onclick="forward10s()" title="Forward 10 seconds">‚è© 10s</button>
            <button class="playback-btn" id="loopBtn" onclick="toggleLoop10s()" title="Loop 10 seconds">
              <span id="loopIcon">üîÅ</span> 10s
            </button>
          </div>
        </div>

        <div class="lyrics-content" id="lyricsContent">
          <div class="lyrics-loading">Loading lyrics...</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Current active platform
    let currentPlatform = 'spotify';
    let currentPlayerPlatform = null;
    let currentSongInfo = null;
    let currentLyricsSource = 'best'; // Default to best lyrics
    let currentSongInfoSource = 'apple';
    let currentSpotifyId = null;
    let currentVideoId = null;

    // Audio control variables
    let audioPlayer = null;
    let youtubePlayer = null;
    let spotifyEmbedController = null;
    let spotifyIframeApi = null;
    let isYoutubeReady = false;
    let isSpotifyEmbedReady = false;
    let isLooping = false;
    let loopStartTime = 0;
    let loopEndTime = 0;
    let progressUpdateInterval = null;

    // Load YouTube API
    const tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    const firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    function onYouTubeIframeAPIReady() {
      isYoutubeReady = true;
    }

    // Load Spotify IFrame API
    const spotifyScript = document.createElement('script');
    spotifyScript.src = "https://open.spotify.com/embed/iframe-api/v1";
    firstScriptTag.parentNode.insertBefore(spotifyScript, firstScriptTag);

    window.onSpotifyIframeApiReady = (IFrameAPI) => {
      spotifyIframeApi = IFrameAPI;
      isSpotifyEmbedReady = true;
      console.log('Spotify IFrame API Ready');
    };

    // Load MusicKit JS
    const musicKitScript = document.createElement('script');
    musicKitScript.src = "https://js-cdn.music.apple.com/musickit/v3/musickit.js";
    musicKitScript.onload = () => {
      console.log('MusicKit JS loaded');
      // Note: MusicKit.configure() is required with a developer token
    };
    firstScriptTag.parentNode.insertBefore(musicKitScript, firstScriptTag);

    let currentPreviewUrl = null;

    // Theme Management
    const themeToggle = document.getElementById('themeToggle');
    const themeIcon = document.getElementById('themeIcon');
    const themeText = document.getElementById('themeText');
    const html = document.documentElement;

    // Load saved theme
    const savedTheme = localStorage.getItem('theme') || 'dark';
    html.setAttribute('data-theme', savedTheme);
    updateThemeIcon(savedTheme);

    function updateThemeIcon(theme) {
      if (theme === 'dark') {
        themeIcon.textContent = 'üåô';
        themeText.textContent = 'Dark';
      } else {
        themeIcon.textContent = '‚òÄÔ∏è';
        themeText.textContent = 'Light';
      }
    }

    themeToggle.addEventListener('click', () => {
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      html.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      updateThemeIcon(newTheme);
    });

    // Platform Tab Switching
    const platformTabs = document.querySelectorAll('.platform-tab');
    const searchPanels = document.querySelectorAll('.search-panel');

    platformTabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const platform = tab.dataset.platform;
        switchPlatform(platform);
      });
    });

    function switchPlatform(platform) {
      currentPlatform = platform;

      // Update active tab
      platformTabs.forEach(t => t.classList.remove('active'));
      document.querySelector(`[data-platform="${platform}"]`).classList.add('active');

      // Update active panel
      searchPanels.forEach(p => p.classList.remove('active'));
      document.getElementById(`${platform}Panel`).classList.add('active');

      // Update search button color
      const searchBtns = document.querySelectorAll('.search-btn');
      searchBtns.forEach(btn => {
        btn.classList.remove('spotify', 'apple', 'youtube');
        btn.classList.add(platform);
      });
    }

    // Update Player Badge
    function updatePlayerBadge(platform) {
      const badge = document.getElementById('playerBadge');
      if (platform) {
        badge.textContent = platform.charAt(0).toUpperCase() + platform.slice(1);
        badge.className = `platform-badge ${platform}`;
        badge.style.display = 'block';
        currentPlayerPlatform = platform;
      } else {
        badge.style.display = 'none';
        currentPlayerPlatform = null;
      }
    }

    // Update Player
    function updatePlayer(embedHtml, platform, songInfo = null, spotifyId = null, previewUrl = null, videoId = null) {
      const player = document.getElementById('player');

      // Cleanup previous players
      if (youtubePlayer) {
        try { youtubePlayer.destroy(); } catch (e) { }
        youtubePlayer = null;
      }
      if (spotifyEmbedController) {
        try { spotifyEmbedController.destroy(); } catch (e) { }
        spotifyEmbedController = null;
      }

      updatePlayerBadge(platform);

      // Store song info for lyrics and song analysis
      if (songInfo) {
        currentSongInfo = songInfo;
        currentSpotifyId = spotifyId;
        currentPreviewUrl = previewUrl;
        currentVideoId = videoId;

        if (platform === 'youtube' && videoId && isYoutubeReady) {
          player.innerHTML = '<div id="youtube-player"></div>';
          youtubePlayer = new YT.Player('youtube-player', {
            height: '220',
            width: '100%',
            videoId: videoId,
            events: {
              'onReady': onPlayerReady,
              'onStateChange': onPlayerStateChange
            }
          });

          cleanupAudioPlayer(false); // Clean up audio but don't hide controls yet

          if (currentLyricsSource === 'write') {
            document.getElementById('playbackControlsBar').style.display = 'block';
          }
        } else if (platform === 'spotify' && spotifyId && isSpotifyEmbedReady) {
          // Use Spotify IFrame API
          player.innerHTML = '<div id="spotify-embed"></div>';
          const element = document.getElementById('spotify-embed');
          const options = {
            uri: `spotify:track:${spotifyId}`,
            width: '100%',
            height: '220',
            theme: 'dark'
          };

          const callback = (EmbedController) => {
            spotifyEmbedController = EmbedController;
            console.log('Spotify Embed Controller created');

            EmbedController.addListener('ready', () => {
              console.log('Spotify Embed Ready');
            });

            EmbedController.addListener('playback_update', e => {
              if (e.data.isPaused) {
                document.getElementById('pauseIcon').textContent = '‚ñ∂Ô∏è';
              } else {
                document.getElementById('pauseIcon').textContent = '‚è∏Ô∏è';
              }
              updateSpotifyProgressWithStore(e.data);
            });
          };

          spotifyIframeApi.createController(element, options, callback);
          cleanupAudioPlayer(false);

          if (currentLyricsSource === 'write') {
            document.getElementById('playbackControlsBar').style.display = 'block';
          }

        } else {
          player.innerHTML = `<div class="player-embed">${embedHtml}</div>`;

          // Setup audio preview if available
          if (previewUrl) {
            setupAudioPreview(previewUrl);
          } else {
            cleanupAudioPlayer();
          }
        }

        // Auto-switch to Apple Music API if available (default)
        if (songInfo) {
          // Keep Apple as default or switch based on logic? 
          // For now, respect the platform choice or user intent
          // If user clicked Spotify search, we might want to keep Spotify tab active
        }

        loadLyrics(songInfo.title, songInfo.artist, currentLyricsSource);

        // Determine which info source to load based on availability
        let infoSource = currentSongInfoSource;
        if (platform === 'spotify') infoSource = 'spotify'; // Prefer Spotify info if playing Spotify
        if (platform === 'apple') infoSource = 'apple';     // Prefer Apple info if playing Apple

        if (platform === 'apple') infoSource = 'apple';     // Prefer Apple info if playing Apple

        loadSongInfo(songInfo.title, songInfo.artist, infoSource, spotifyId);
      } else {
        currentSongInfo = null;
        currentSpotifyId = null;
        currentPreviewUrl = null;
        cleanupAudioPlayer();
        document.getElementById('lyricsSection').style.display = 'none';
        document.getElementById('songInfoSection').style.display = 'none';
      }

      // Auto-switch to the platform tab
      if (platform !== currentPlatform) {
        switchPlatform(platform);
      }
    }

    // Setup Audio Preview Player
    function setupAudioPreview(previewUrl) {
      cleanupAudioPlayer();

      if (!previewUrl) return;

      audioPlayer = new Audio(previewUrl);
      audioPlayer.preload = 'auto';

      // Update progress bar on timeupdate
      audioPlayer.addEventListener('timeupdate', updateProgressBar);
      audioPlayer.addEventListener('loadedmetadata', () => {
        updateTotalTime();
      });
      audioPlayer.addEventListener('ended', () => {
        if (isLooping) {
          audioPlayer.currentTime = loopStartTime;
          audioPlayer.play();
        }
      });

      // Show playback controls if in write mode
      if (currentLyricsSource === 'write') {
        document.getElementById('playbackControlsBar').style.display = 'block';
      }
    }

    // Cleanup Audio Player
    function cleanupAudioPlayer(hideControls = true) {
      if (audioPlayer) {
        audioPlayer.pause();
        audioPlayer = null;
      }
      if (progressUpdateInterval) {
        clearInterval(progressUpdateInterval);
        progressUpdateInterval = null;
      }
      isLooping = false;
      if (hideControls) {
        document.getElementById('playbackControlsBar').style.display = 'none';
      }
    }

    // YouTube Player Events
    function onPlayerReady(event) {
      updateTotalTime();
    }

    function onPlayerStateChange(event) {
      if (event.data == YT.PlayerState.PLAYING) {
        document.getElementById('pauseIcon').textContent = '‚è∏Ô∏è';
        if (!progressUpdateInterval) {
          progressUpdateInterval = setInterval(updateProgressBar, 500);
        }
      } else {
        document.getElementById('pauseIcon').textContent = '‚ñ∂Ô∏è';
        if (event.data != YT.PlayerState.BUFFERING) {
          if (progressUpdateInterval) {
            clearInterval(progressUpdateInterval);
            progressUpdateInterval = null;
          }
        }
      }
    }

    // Update Spotify Progress
    function updateSpotifyProgress(data) {
      const duration = data.duration / 1000;
      const position = data.position / 1000;
      const progress = (position / duration) * 100;

      const progressBar = document.getElementById('playbackProgress');
      if (progressBar) {
        progressBar.value = progress || 0;
      }

      const currentTimeEl = document.getElementById('currentTime');
      if (currentTimeEl) {
        currentTimeEl.textContent = formatTime(position);
      }

      const totalTimeEl = document.getElementById('totalTime');
      if (totalTimeEl) {
        totalTimeEl.textContent = formatTime(duration);
      }
    }

    // Update Progress Bar
    function updateProgressBar() {
      let currentTime = 0;
      let duration = 0;

      if (audioPlayer && audioPlayer.duration) {
        currentTime = audioPlayer.currentTime;
        duration = audioPlayer.duration;
      } else if (youtubePlayer && youtubePlayer.getCurrentTime) {
        try {
          currentTime = youtubePlayer.getCurrentTime();
          duration = youtubePlayer.getDuration();
        } catch (e) { }
      } else {
        // Spotify updates via event listener, so we don't need polling here
        // But we might need to handle the loop logic if Spotify doesn't support it natively
        return;
      }

      const progress = duration ? (currentTime / duration) * 100 : 0;
      const progressBar = document.getElementById('playbackProgress');
      if (progressBar) {
        progressBar.value = progress || 0;
      }

      updateCurrentTime();

      // Handle 10-second loop
      if (isLooping && currentTime >= loopEndTime) {
        if (audioPlayer) audioPlayer.currentTime = loopStartTime;
        else if (youtubePlayer) youtubePlayer.seekTo(loopStartTime, true);
        else if (spotifyEmbedController) spotifyEmbedController.seek(loopStartTime);
      }
    }

    // Update Current Time Display
    function updateCurrentTime() {
      let currentTime = 0;
      if (audioPlayer) currentTime = audioPlayer.currentTime;
      else if (youtubePlayer && youtubePlayer.getCurrentTime) {
        try { currentTime = youtubePlayer.getCurrentTime(); } catch (e) { }
      }

      const currentTimeEl = document.getElementById('currentTime');
      if (currentTimeEl) {
        currentTimeEl.textContent = formatTime(currentTime);
      }
    }

    // Update Total Time Display
    function updateTotalTime() {
      let duration = 0;
      if (audioPlayer) duration = audioPlayer.duration;
      else if (youtubePlayer && youtubePlayer.getDuration) {
        try { duration = youtubePlayer.getDuration(); } catch (e) { }
      }

      const totalTimeEl = document.getElementById('totalTime');
      if (totalTimeEl) {
        totalTimeEl.textContent = formatTime(duration);
      }
    }

    // Format Time
    function formatTime(seconds) {
      if (!seconds || isNaN(seconds)) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Toggle Pause
    function togglePause() {
      if (audioPlayer) {
        if (audioPlayer.paused) {
          audioPlayer.play();
          document.getElementById('pauseIcon').textContent = '‚è∏Ô∏è';
        } else {
          audioPlayer.pause();
          document.getElementById('pauseIcon').textContent = '‚ñ∂Ô∏è';
        }
      } else if (youtubePlayer && youtubePlayer.getPlayerState) {
        try {
          if (youtubePlayer.getPlayerState() == YT.PlayerState.PLAYING) {
            youtubePlayer.pauseVideo();
            document.getElementById('pauseIcon').textContent = '‚ñ∂Ô∏è';
          } else {
            youtubePlayer.playVideo();
            document.getElementById('pauseIcon').textContent = '‚è∏Ô∏è';
          }
        } catch (e) { }
      } else if (spotifyEmbedController) {
        spotifyEmbedController.togglePlay();
      }
    }

    // Rewind 10 Seconds
    function rewind10s() {
      if (audioPlayer) {
        audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - 10);
        updateProgressBar();
      } else if (youtubePlayer && youtubePlayer.getCurrentTime) {
        try {
          const time = Math.max(0, youtubePlayer.getCurrentTime() - 10);
          youtubePlayer.seekTo(time, true);
          updateProgressBar();
        } catch (e) { }
      } else if (spotifyEmbedController) {
        spotifyEmbedController.seek(-10); // Relative seek not supported directly usually, need current pos
        // Actually EmbedController.seek takes seconds (float)
        // We don't have current time in variable unless we track it
        // But we can just emit a seek command if we know the position?
        // No, let's use the tracked position from events if possible, or we need to request state?
        // The controller doesn't expose 'getCurrentTime' synchronously.
        // Wait, the API documentation says .seek(seconds) seeks to position.
        // So we need to track current position.
      }
    }

    // Since we receive playback_update events, let's store the last known position
    let lastSpotifyPosition = 0;

    // Update updateSpotifyProgress to store position
    function updateSpotifyProgressWithStore(data) {
      lastSpotifyPosition = data.position / 1000;
      updateSpotifyProgress(data);

      // Handle loop
      if (isLooping && lastSpotifyPosition >= loopEndTime) {
        spotifyEmbedController.seek(loopStartTime);
      }
    }

    // Redefine rewind/forward for Spotify
    function rewind10sSpotify() {
      if (spotifyEmbedController) {
        const newPos = Math.max(0, lastSpotifyPosition - 10);
        spotifyEmbedController.seek(newPos);
      }
    }

    function forward10sSpotify() {
      if (spotifyEmbedController) {
        const newPos = lastSpotifyPosition + 10;
        spotifyEmbedController.seek(newPos);
      }
    }

    // Updated Main Functions
    function rewind10s() {
      if (audioPlayer) {
        audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - 10);
        updateProgressBar();
      } else if (youtubePlayer && youtubePlayer.getCurrentTime) {
        try {
          const time = Math.max(0, youtubePlayer.getCurrentTime() - 10);
          youtubePlayer.seekTo(time, true);
          updateProgressBar();
        } catch (e) { }
      } else if (spotifyEmbedController) {
        rewind10sSpotify();
      }
    }

    function forward10s() {
      if (audioPlayer) {
        audioPlayer.currentTime = Math.min(audioPlayer.duration, audioPlayer.currentTime + 10);
        updateProgressBar();
      } else if (youtubePlayer && youtubePlayer.getCurrentTime) {
        try {
          const duration = youtubePlayer.getDuration();
          const time = Math.min(duration, youtubePlayer.getCurrentTime() + 10);
          youtubePlayer.seekTo(time, true);
          updateProgressBar();
        } catch (e) { }
      } else if (spotifyEmbedController) {
        forward10sSpotify();
      }
    }

    // Toggle Loop 10 Seconds
    function toggleLoop10s() {
      if (!audioPlayer && !youtubePlayer && !spotifyEmbedController) return;

      isLooping = !isLooping;
      const loopBtn = document.getElementById('loopBtn');

      let currentTime = 0;
      if (audioPlayer) currentTime = audioPlayer.currentTime;
      else if (youtubePlayer && youtubePlayer.getCurrentTime) {
        try { currentTime = youtubePlayer.getCurrentTime(); } catch (e) { }
      } else if (spotifyEmbedController) {
        currentTime = lastSpotifyPosition;
      }

      if (isLooping) {
        loopStartTime = currentTime;
        loopEndTime = loopStartTime + 10;
        loopBtn.classList.add('active');
        document.getElementById('loopIcon').textContent = 'üîÇ';
      } else {
        loopBtn.classList.remove('active');
        document.getElementById('loopIcon').textContent = 'üîÅ';
      }
    }

    // Handle Progress Bar Seek
    document.addEventListener('DOMContentLoaded', () => {
      checkLoginStatus();
      // Wait a bit for MusicKit to load
      setTimeout(checkAppleLoginStatus, 1000);

      const progressBar = document.getElementById('playbackProgress');
      if (progressBar) {
        progressBar.addEventListener('input', (e) => {
          if (audioPlayer && audioPlayer.duration) {
            const seekTime = (e.target.value / 100) * audioPlayer.duration;
            audioPlayer.currentTime = seekTime;
            updateProgressBar();
          } else if (youtubePlayer && youtubePlayer.getDuration) {
            try {
              const seekTime = (e.target.value / 100) * youtubePlayer.getDuration();
              youtubePlayer.seekTo(seekTime, true);
              updateProgressBar();
            } catch (e) { }
          } else if (spotifyEmbedController) {
            // We need duration for Spotify seek
            // Store duration from update event
            // Assuming totalTimeEl has it or we stored it?
            // Let's store duration too
          }
        });
      }
    });

    // Switch Song Info Source
    function switchSongInfoSource(source) {
      currentSongInfoSource = source;
      document.querySelectorAll('.song-info-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.source === source);
      });

      if (currentSongInfo) {
        loadSongInfo(currentSongInfo.title, currentSongInfo.artist, source, currentSpotifyId);
      }
    }

    // Load Song Info
    async function loadSongInfo(title, artist, source = 'apple', spotifyId = null) {
      const songInfoSection = document.getElementById('songInfoSection');
      const songInfoContent = document.getElementById('songInfoContent');

      songInfoSection.style.display = 'block';
      songInfoContent.innerHTML = '<div class="song-info-loading">Loading song info...</div>';

      try {
        let data = null;

        if (source === 'spotify') {
          // Spotify requires track ID
          if (!spotifyId) {
            songInfoContent.innerHTML = '<div class="song-info-error">Spotify track ID required. Please select a Spotify track.</div>';
            return;
          }
          data = await fetchSpotifyInfo(title, artist, spotifyId);
        } else if (source === 'apple') {
          data = await fetchAppleMusicInfo(title, artist);
        }

        if (data && !data.error) {
          displaySongInfo(data);
        } else {
          const errorMsg = data?.error || 'Song info unavailable.';
          songInfoContent.innerHTML = `<div class="song-info-error">${errorMsg}</div>`;
        }

        // Handle Player for Apple Music - REMOVED to prevent infinite loop
      } catch (error) {
        console.error('Song info fetch error:', error);
        songInfoContent.innerHTML = '<div class="song-info-error">Error loading song info. Please try again.</div>';
      }
    }

    // Fetch Apple Music Info
    async function fetchAppleMusicInfo(title, artist) {
      try {
        const url = `/api/apple-music-info?title=${encodeURIComponent(title)}&artist=${encodeURIComponent(artist)}`;
        console.log('Fetching Apple Music Info with:', { title, artist, url });

        const response = await fetch(url);
        if (response.ok) {
          return await response.json();
        }
        return await response.json().catch(() => ({ error: 'Apple Music data unavailable' }));
      } catch (error) {
        console.error('Apple Music Info fetch error:', error);
        return { error: 'Failed to fetch from Apple Music: ' + error.message };
      }
    }

    // Fetch Spotify Info
    async function fetchSpotifyInfo(title, artist, spotifyId) {
      try {
        const url = `/api/spotify-info?title=${encodeURIComponent(title)}&artist=${encodeURIComponent(artist)}&spotifyId=${encodeURIComponent(spotifyId)}`;

        console.log('Fetching Spotify Info with:', { title, artist, spotifyId, url });
        const response = await fetch(url);

        if (response.ok) {
          const data = await response.json();
          console.log('Spotify Info response:', data);
          return data;
        }
        const errorData = await response.json().catch(() => ({ error: 'Spotify API data unavailable' }));
        return errorData;
      } catch (error) {
        console.error('Spotify Info fetch error:', error);
        return { error: 'Failed to fetch from Spotify API: ' + error.message };
      }
    }

    // Display Song Info
    function displaySongInfo(data) {
      const songInfoContent = document.getElementById('songInfoContent');

      const infoItems = [];

      if (data.bpm || data.tempo) {
        infoItems.push({
          label: 'BPM',
          value: Math.round(data.bpm || data.tempo || 0),
          large: true
        });
      }

      if (data.key) {
        infoItems.push({
          label: 'Key',
          value: data.key,
          large: true
        });
      }

      if (data.energy !== undefined) {
        infoItems.push({
          label: 'Energy',
          value: `${data.energy}%`,
          progress: data.energy
        });
      }

      if (data.danceability !== undefined) {
        infoItems.push({
          label: 'Danceability',
          value: `${data.danceability}%`,
          progress: data.danceability
        });
      }

      if (data.valence !== undefined) {
        infoItems.push({
          label: 'Valence',
          value: `${data.valence}%`,
          progress: data.valence
        });
      }

      if (data.acousticness !== undefined) {
        infoItems.push({
          label: 'Acousticness',
          value: `${data.acousticness}%`,
          progress: data.acousticness
        });
      }

      if (data.instrumentalness !== undefined) {
        infoItems.push({
          label: 'Instrumental',
          value: `${data.instrumentalness}%`,
          progress: data.instrumentalness
        });
      }

      if (data.liveness !== undefined) {
        infoItems.push({
          label: 'Liveness',
          value: `${data.liveness}%`,
          progress: data.liveness
        });
      }

      if (data.speechiness !== undefined) {
        infoItems.push({
          label: 'Speechiness',
          value: `${data.speechiness}%`,
          progress: data.speechiness
        });
      }

      if (data.timeSignature) {
        infoItems.push({
          label: 'Time Sig',
          value: `${data.timeSignature}/4`
        });
      }

      if (data.popularity !== undefined) {
        infoItems.push({
          label: 'Popularity',
          value: `${data.popularity}%`,
          progress: data.popularity
        });
      }

      if (data.duration) {
        const minutes = Math.floor(data.duration / 60000);
        const seconds = Math.floor((data.duration % 60000) / 1000);
        infoItems.push({
          label: 'Duration',
          value: `${minutes}:${seconds.toString().padStart(2, '0')}`
        });
      }

      // Additional Spotify API info
      if (data.albumName) {
        infoItems.push({
          label: 'Album',
          value: data.albumName
        });
      }

      if (data.releaseDate) {
        infoItems.push({
          label: 'Release',
          value: data.releaseDate
        });
      }

      if (data.explicit !== undefined) {
        infoItems.push({
          label: 'Explicit',
          value: data.explicit ? 'Yes' : 'No'
        });
      }

      if (data.albumType) {
        infoItems.push({
          label: 'Type',
          value: data.albumType.charAt(0).toUpperCase() + data.albumType.slice(1)
        });
      }

      if (data.totalTracks) {
        infoItems.push({
          label: 'Tracks',
          value: data.totalTracks.toString()
        });
      }

      if (data.artistGenres && data.artistGenres.length > 0) {
        infoItems.push({
          label: 'Genres',
          value: data.artistGenres.slice(0, 3).join(', ')
        });
      }

      if (data.artistFollowers !== null && data.artistFollowers !== undefined) {
        const followers = data.artistFollowers >= 1000000
          ? (data.artistFollowers / 1000000).toFixed(1) + 'M'
          : data.artistFollowers >= 1000
            ? (data.artistFollowers / 1000).toFixed(1) + 'K'
            : data.artistFollowers.toString();
        infoItems.push({
          label: 'Followers',
          value: followers
        });
      }

      if (data.artistPopularity !== null && data.artistPopularity !== undefined) {
        infoItems.push({
          label: 'Artist Pop',
          value: `${data.artistPopularity}%`,
          progress: data.artistPopularity
        });
      }

      if (data.label) {
        infoItems.push({
          label: 'Label',
          value: data.label
        });
      }

      if (infoItems.length === 0) {
        songInfoContent.innerHTML = '<div class="song-info-error">No song data available</div>';
        return;
      }

      const html = `
        <div class="song-info-grid">
          ${infoItems.map(item => `
            <div class="song-info-item">
              <div class="song-info-label">${item.label}</div>
              <div class="song-info-value ${item.large ? 'song-info-value-large' : ''}">${item.value}</div>
              ${item.progress !== undefined ? `
                <div class="progress-bar">
                  <div class="progress-fill" style="width: ${item.progress}%"></div>
                </div>
              ` : ''}
            </div>
          `).join('')}
</div>
      `;

      songInfoContent.innerHTML = html;
    }

    // Switch Lyrics Source
    function switchLyricsSource(source) {
      currentLyricsSource = source;
      document.querySelectorAll('.lyrics-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.source === source);
      });

      // Show/hide playback controls based on write mode
      const playbackBar = document.getElementById('playbackControlsBar');
      if (source === 'write') {
        if (currentPreviewUrl) {
          if (!audioPlayer) {
            setupAudioPreview(currentPreviewUrl);
          }
          playbackBar.style.display = 'block';
        } else if (currentVideoId && youtubePlayer) {
          playbackBar.style.display = 'block';
        } else {
          playbackBar.style.display = 'none';
        }
      } else {
        playbackBar.style.display = 'none';
      }

      if (currentSongInfo) {
        loadLyrics(currentSongInfo.title, currentSongInfo.artist, source);
      }
    }

    // Load Lyrics
    async function loadLyrics(title, artist, source = 'best') {
      const lyricsSection = document.getElementById('lyricsSection');
      const lyricsContent = document.getElementById('lyricsContent');
      const lyricsSource = document.getElementById('lyricsSource');

      lyricsSection.style.display = 'block';
      lyricsContent.innerHTML = '<div class="lyrics-loading">Loading lyrics...</div>';

      try {
        let lyrics = null;
        let sourceName = '';

        if (source === 'write') {
          // Show lyrics writing editor
          setupLyricsWriter();
          lyricsSource.textContent = 'Write';
          return;
        } else if (source === 'best') {
          const result = await fetchBestLyrics(title, artist);
          if (result && result.lyrics) {
            lyrics = result.lyrics;
            sourceName = result.source;
            lyricsSource.textContent = `Best from ${result.source}`;
          } else {
            lyricsContent.innerHTML = '<div class="lyrics-error">No lyrics found from any source. Try individual sources.</div>';
            return;
          }
        } else if (source === 'genius') {
          lyrics = await fetchGeniusLyrics(title, artist);
          sourceName = 'Genius';
          lyricsSource.textContent = 'Genius';
        } else {
          lyrics = await fetchLRCLibLyrics(title, artist);
          sourceName = 'LRCLib';
          lyricsSource.textContent = 'LRCLib';
        }

        if (lyrics) {
          lyricsContent.innerHTML = `<div class="lyrics-content">${lyrics}</div>`;
        } else {
          lyricsContent.innerHTML = '<div class="lyrics-error">Lyrics not found. Try switching sources.</div>';
        }
      } catch (error) {
        console.error('Lyrics fetch error:', error);
        lyricsContent.innerHTML = '<div class="lyrics-error">Error loading lyrics. Please try again.</div>';
      }
    }

    // Fetch Best Lyrics
    async function fetchBestLyrics(title, artist) {
      try {
        const response = await fetch(
          `/api/best-lyrics?title=${encodeURIComponent(title)}&artist=${encodeURIComponent(artist)}`
        );

        if (response.ok) {
          const data = await response.json();
          if (data.lyrics) {
            return data;
          }
        }
        return null;
      } catch (error) {
        console.error('Best lyrics fetch error:', error);
        return null;
      }
    }

    // Fetch Genius Lyrics
    async function fetchGeniusLyrics(title, artist) {
      try {
        // Use server-side API endpoint
        const response = await fetch(
          `/api/genius-lyrics?title=${encodeURIComponent(title)}&artist=${encodeURIComponent(artist)}`
        );

        if (response.ok) {
          const data = await response.json();
          if (data.url) {
            // For now, return a link. Full lyrics scraping would require server-side implementation
            return `Lyrics available on Genius:\n${data.url}\n\nNote: Full lyrics display requires Genius API access token in environment variables.`;
          }
        }

        // Fallback to LRCLib
        return await fetchLRCLibLyrics(title, artist);
      } catch (error) {
        console.error('Genius fetch error:', error);
        // Fallback to LRCLib
        return await fetchLRCLibLyrics(title, artist);
      }
    }

    // Setup Lyrics Writer
    function setupLyricsWriter() {
      const lyricsContent = document.getElementById('lyricsContent');
      const savedLyrics = localStorage.getItem(`lyrics_${getSongKey()}`) || '';

      lyricsContent.innerHTML = `
        <div class="lyrics-editor-container">
          <div class="lyrics-editor-toolbar">
            <button class="search-btn" onclick="insertTimestamp()" title="Insert timestamp at current position">Insert Time</button>
            <button class="search-btn" onclick="saveLyrics()" title="Save lyrics">Save</button>
            <button class="search-btn" onclick="clearLyrics()" title="Clear editor">Clear</button>
          </div>
          <textarea id="lyricsEditor" class="lyrics-editor-textarea" placeholder="Start writing your lyrics here...">${savedLyrics}</textarea>
        </div>
      `;
    }

    function getSongKey() {
      if (currentSongInfo && currentSongInfo.title) {
        return `${currentSongInfo.title} - ${currentSongInfo.artist}`;
      }
      return 'untitled';
    }

    function insertTimestamp() {
      let currentTime = 0;
      if (audioPlayer) {
        currentTime = audioPlayer.currentTime;
      } else if (youtubePlayer && youtubePlayer.getCurrentTime) {
        try { currentTime = youtubePlayer.getCurrentTime(); } catch (e) { }
      } else {
        alert('No audio playing. Please select a song with preview or YouTube video.');
        return;
      }

      const editor = document.getElementById('lyricsEditor');
      if (!editor) return;

      const time = currentTime;
      const timestamp = formatTimestamp(time);
      const cursorPos = editor.selectionStart;
      const textBefore = editor.value.substring(0, cursorPos);
      const textAfter = editor.value.substring(editor.selectionEnd);
      editor.value = textBefore + timestamp + '\n' + textAfter;
      editor.focus();
      editor.setSelectionRange(cursorPos + timestamp.length + 1, cursorPos + timestamp.length + 1);
    }

    function formatTimestamp(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      const centis = Math.floor((seconds % 1) * 100);
      return `[${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${centis.toString().padStart(2, '0')}]`;
    }

    function saveLyrics() {
      const editor = document.getElementById('lyricsEditor');
      if (!editor) return;

      localStorage.setItem(`lyrics_${getSongKey()}`, editor.value);
      alert('Lyrics saved!');
    }

    function clearLyrics() {
      if (confirm('Are you sure you want to clear the lyrics editor?')) {
        const editor = document.getElementById('lyricsEditor');
        if (editor) {
          editor.value = '';
          localStorage.removeItem(`lyrics_${getSongKey()}`);
        }
      }
    }

    // Fetch LRCLib Lyrics
    async function fetchLRCLibLyrics(title, artist) {
      try {
        // Clean song title and artist for better matching
        const cleanTitle = title.replace(/\([^)]*\)/g, '').trim();
        const cleanArtist = artist.split(',')[0].trim();

        // Try LRCLib API
        const searchQuery = `${cleanTitle} ${cleanArtist}`;
        const response = await fetch(
          `https://lrclib.net/api/search?q=${encodeURIComponent(searchQuery)}&limit=1`
        );

        if (response.ok) {
          const data = await response.json();
          if (data && data.length > 0 && data[0].syncedLyrics) {
            // Return synced lyrics
            const lyrics = data[0].syncedLyrics;
            // Format synced lyrics (remove timestamps for display or show them)
            const formattedLyrics = lyrics
              .replace(/\[(\d{2}):(\d{2})\.(\d{2,3})\]/g, '') // Remove timestamps
              .trim();
            return formattedLyrics || data[0].plainLyrics || 'Lyrics found but empty.';
          } else if (data && data.length > 0 && data[0].plainLyrics) {
            return data[0].plainLyrics;
          }
        }

        // Try alternative: search by track name only
        const titleOnlyResponse = await fetch(
          `https://lrclib.net/api/search?q=${encodeURIComponent(cleanTitle)}&limit=3`
        );

        if (titleOnlyResponse.ok) {
          const titleData = await titleOnlyResponse.json();
          if (titleData && titleData.length > 0) {
            // Find best match by artist
            const match = titleData.find(track =>
              track.artistName && track.artistName.toLowerCase().includes(cleanArtist.toLowerCase())
            ) || titleData[0];

            if (match.plainLyrics) {
              return match.plainLyrics;
            } else if (match.syncedLyrics) {
              return match.syncedLyrics.replace(/\[(\d{2}):(\d{2})\.(\d{2,3})\]/g, '').trim();
            }
          }
        }

        return null;
      } catch (error) {
        console.error('LRCLib fetch error:', error);
        return null;
      }
    }

    // Spotify Login
    function login() {
      window.location.href = "/api/login";
    }

    // Check Login Status
    async function checkLoginStatus() {
      try {
        const tokenResponse = await fetch("/api/token");
        const tokenData = await tokenResponse.json();

        const loginBtn = document.getElementById('spotifyLoginBtn');
        const userStatus = document.getElementById('spotifyUserStatus');

        if (tokenData.access_token) {
          if (loginBtn) loginBtn.style.display = 'none';
          if (userStatus) {
            userStatus.style.display = 'inline';
            userStatus.textContent = 'Logged In';

            // Try to get user info
            try {
              const meResponse = await fetch('https://api.spotify.com/v1/me', {
                headers: { Authorization: "Bearer " + tokenData.access_token }
              });
              if (meResponse.ok) {
                const meData = await meResponse.json();
                userStatus.textContent = meData.display_name || 'Logged In';
              }
            } catch (e) {
              console.error('Error fetching user profile', e);
            }
          }
        } else {
          if (loginBtn) loginBtn.style.display = 'block';
          if (userStatus) userStatus.style.display = 'none';
        }
      } catch (error) {
        console.error('Error checking login status:', error);
      }
    }

    // Removed renderAppleMusicEmbed and restoreCustomPlayer as updatePlayer handles it

    // Modification to switchSongInfoSource

    // Modification to switchSongInfoSource to restore player if not apple
    const originalSwitchSource = switchSongInfoSource;
    switchSongInfoSource = function (source) {
      currentSongInfoSource = source;
      document.querySelectorAll('.song-info-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.source === source);
      });

      if (source !== 'apple') {
        // Logic for others if needed, updatePlayer handles clearing
      }

      if (currentSongInfo) {
        loadSongInfo(currentSongInfo.title, currentSongInfo.artist, source, currentSpotifyId);
      }
    };

    // Removed old Login/Auth functions as they are not needed for Embeds

    // Spotify Search
    async function spotifySearch() {
      const query = document.getElementById('sQuery').value.trim();
      if (!query) return;

      const sResults = document.getElementById('sResults');
      sResults.innerHTML = '<div class="player-placeholder">Searching...</div>';

      try {
        const tokenResponse = await fetch("/api/token");
        const tokenData = await tokenResponse.json();

        if (!tokenData.access_token) {
          sResults.innerHTML = '<div class="player-placeholder">Please login to Spotify first</div>';
          return;
        }

        const response = await fetch(
          `https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=10`,
          { headers: { Authorization: "Bearer " + tokenData.access_token } }
        );
        const data = await response.json();

        sResults.innerHTML = "";
        if (data.tracks && data.tracks.items.length > 0) {
          data.tracks.items.forEach(track => {
            const div = document.createElement("div");
            div.className = "result-item";
            div.innerHTML = `
              <div class="result-title">${track.name}</div>
              <div class="result-artist">${track.artists.map(a => a.name).join(', ')}</div>
            `;
            div.onclick = () => {
              const spotifyTrackId = track.id;
              console.log('Spotify track selected:', { id: spotifyTrackId, name: track.name, artist: track.artists.map(a => a.name).join(', ') });
              const embedHtml = `<iframe src="https://open.spotify.com/embed/track/${spotifyTrackId}" width="100%" height="152" frameborder="0" allowtransparency="true" allow="autoplay; encrypted-media"></iframe>`;
              updatePlayer(embedHtml, 'spotify', {
                title: track.name,
                artist: track.artists.map(a => a.name).join(', ')
              }, spotifyTrackId, track.preview_url || null);
            };
            sResults.appendChild(div);
          });
        } else {
          sResults.innerHTML = '<div class="player-placeholder">No results found</div>';
        }
      } catch (error) {
        sResults.innerHTML = '<div class="player-placeholder">Error searching. Please try again.</div>';
        console.error('Spotify search error:', error);
      }
    }

    // Apple Music Search
    async function appleSearch() {
      const query = document.getElementById('aQuery').value.trim();
      if (!query) return;

      const aResults = document.getElementById('aResults');
      aResults.innerHTML = '<div class="player-placeholder">Searching...</div>';

      try {
        const response = await fetch(
          `https://itunes.apple.com/search?term=${encodeURIComponent(query)}&entity=song&limit=10`
        );
        const data = await response.json();

        aResults.innerHTML = "";
        if (data.results && data.results.length > 0) {
          data.results.forEach(track => {
            const div = document.createElement("div");
            div.className = "result-item";
            div.innerHTML = `
              <div class="result-title">${track.trackName}</div>
              <div class="result-artist">${track.artistName}</div>
            `;
            div.onclick = () => {
              const embedUrl = track.trackViewUrl.replace(
                "music.apple.com",
                "embed.music.apple.com"
              );
              const embedHtml = `<iframe src="${embedUrl}" width="100%" height="150" frameborder="0" allowtransparency="true" allow="autoplay; encrypted-media"></iframe>`;
              updatePlayer(embedHtml, 'apple', {
                title: track.trackName,
                artist: track.artistName
              }, null, track.previewUrl || null);
            };
            aResults.appendChild(div);
          });
        } else {
          aResults.innerHTML = '<div class="player-placeholder">No results found</div>';
        }
      } catch (error) {
        aResults.innerHTML = '<div class="player-placeholder">Error searching. Please try again.</div>';
        console.error('Apple Music search error:', error);
      }
    }

    // YouTube Search
    async function youtubeSearch() {
      const query = document.getElementById('yQuery').value.trim();
      if (!query) return;

      const yResults = document.getElementById('yResults');
      yResults.innerHTML = '<div class="player-placeholder">Searching...</div>';

      try {
        const response = await fetch(
          `/api/youtube-search?q=${encodeURIComponent(query)}`
        );
        const data = await response.json();

        yResults.innerHTML = "";
        if (data.items && data.items.length > 0) {
          data.items.forEach(video => {
            const div = document.createElement("div");
            div.className = "result-item";
            div.innerHTML = `
              <div class="result-title">${video.snippet.title}</div>
              <div class="result-artist">${video.snippet.channelTitle}</div>
            `;
            div.onclick = () => {
              const embedHtml = `<iframe width="100%" height="220" src="https://www.youtube.com/embed/${video.id.videoId}" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>`;
              // Extract artist from title if possible (common format: "Song Name - Artist")
              const titleParts = video.snippet.title.split(' - ');
              updatePlayer(embedHtml, 'youtube', {
                title: titleParts[0] || video.snippet.title,
                artist: titleParts[1] || video.snippet.channelTitle
              }, null, null, video.id.videoId);
            };
            yResults.appendChild(div);
          });
        } else {
          yResults.innerHTML = '<div class="player-placeholder">No results found</div>';
        }
      } catch (error) {
        yResults.innerHTML = '<div class="player-placeholder">Error searching. Please try again.</div>';
        console.error('YouTube search error:', error);
      }
    }
  </script>
</body>

</html>